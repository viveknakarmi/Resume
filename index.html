<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Interactive Resume City</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #14141E, #1E3A5F);
            color: #FFFFFF;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 720px;
            border: 2px solid #00DDEB;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(20, 20, 30, 0.9);
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            transition: filter 0.3s ease;
        }
        #game-canvas.blur {
            filter: blur(3px);
        }
        .popup, .welcome-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #00DDEB;
            border-radius: 8px;
            padding: 1.5rem;
            width: 85%;
            max-width: 400px;
            min-height: 200px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 221, 235, 0.5);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .popup.active, .welcome-popup.active {
            display: block;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        .popup:hover {
            transform: translate(-50%, -50%) scale(1.02);
        }
        .popup h2, .welcome-popup h2 {
            color: #FFFFFF;
            font-size: 1.8rem;
            margin: 0 0 0.8rem;
            font-weight: 700;
        }
        .popup p, .popup li, .welcome-popup p {
            color: #A3BFFA;
            font-size: 1rem;
            line-height: 1.6;
            text-align: left;
        }
        .popup ul {
            list-style: disc;
            margin: 1rem 0;
            padding-left: 1.5rem;
        }
        .popup a, .welcome-popup a {
            color: #00DDEB;
            text-decoration: none;
        }
        .popup a:hover, .welcome-popup a:hover {
            text-decoration: underline;
        }
        .close-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #FFFFFF;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-btn:hover {
            color: #00DDEB;
        }
        .instructions {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 1rem;
            color: #A3BFFA;
            position: absolute;
            bottom: 5px;
            width: 100%;
        }
        .progress-bar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 12px;
            background: #2A2A3A;
            border: 1px solid #00DDEB;
            border-radius: 4px;
        }
        .progress-fill {
            height: 100%;
            background: #00DDEB;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .timeline-link {
            background: #00DDEB;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            color: #14141E;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            transition: background 0.2s ease;
            margin: 0 0.5rem;
        }
        .button-container {
            position: absolute;
            top: 10px;
            display: flex;
            justify-content: center;
            width: 100%;
            z-index: 15;
        }
        .timeline-link:hover {
            background: #00B7C2;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 221, 235, 0.9);
            color: #14141E;
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 5;
            display: none;
        }
        .controls {
            position: fixed;
            bottom: 15px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 15;
        }
        .control-btn {
            background: #00DDEB;
            color: #14141E;
            border: none;
            border-radius: 8px;
            padding: 12px;
            font-size: 1.2rem;
            cursor: pointer;
            opacity: 0.8;
            touch-action: manipulation;
        }
        .control-btn:active {
            opacity: 1;
            transform: scale(0.95);
        }
        .left-right {
            display: flex;
            gap: 15px;
        }
        @media (min-width: 768px) {
            .controls {
                display: none;
            }
            .instructions {
                display: block;
            }
            .instructions-mobile {
                display: none;
            }
        }
        @media (max-width: 767px) {
            .instructions {
                display: none;
            }
            .instructions-mobile {
                text-align: center;
                margin-top: 0.5rem;
                font-size: 0.9rem;
                color: #A3BFFA;
                display: block;
                position: absolute;
                bottom: 5px;
                width: 100%;
            }
            #game-container {
                max-height: 85vh;
            }
            .popup h2, .welcome-popup h2 {
                font-size: 1.6rem;
            }
            .popup p, .popup li, .welcome-popup p {
                font-size: 0.95rem;
            }
        }
    </style>
    <script>
        function closePopup(id) {
            document.getElementById(id).classList.remove('active');
            document.getElementById('game-canvas').classList.remove('blur');
        }

        function closeAllPopups() {
            document.querySelectorAll('.popup, .welcome-popup').forEach(popup => {
                popup.classList.remove('active');
            });
            document.getElementById('game-canvas').classList.remove('blur');
        }
    </script>
</head>
<body>
    <div class="button-container">
        <a href="timeline.html" class="timeline-link">Career Timeline</a>
    </div>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
    <div class="instructions">Use Arrow Keys/WASD to move, Space to jump, Enter to interact, Esc to close popups</div>
    <div class="instructions-mobile">Use on-screen buttons to move, jump, and interact</div>

    <!-- Welcome Popup -->
    <div class="welcome-popup active" id="welcome-popup">
        <button class="close-btn" onclick="closePopup('welcome-popup')">×</button>
        <h2>Welcome to My Resume City!</h2>
        <p>Passionate about data analytics and payroll efficiency. Skilled in SQL, Looker Studio, and VBA. Explore my career in this vibrant city! On desktop, use Arrow Keys or WASD to move, Space to jump, and Enter to interact. On mobile, use the on-screen buttons. The current role pulses with energy. Press the close button to close popups. Follow the glowing timeline across 5-year levels (2013–2017 at the bottom, 2018–2022 in the middle, 2023–Present at the top). Below lies a bustling underground metro—observe its vibrancy! Check out my <a href="https://www.linkedin.com/in/vivek-anand-nakarmi-9b8a42a3" target="_blank">LinkedIn</a> or view the Career Timeline link!</p>
        <div class="btn" onclick="closePopup('welcome-popup')">Start Exploring</div>
    </div>

    <!-- Dynamic Popups Container -->
    <div id="popups-container"></div>

    <!-- Touch Controls -->
    <div class="controls">
        <div class="left-right">
            <button class="control-btn" id="left-btn">←</button>
            <button class="control-btn" id="right-btn">→</button>
        </div>
        <div class="actions">
            <button class="control-btn" id="jump-btn">Jump</button>
            <button class="control-btn" id="interact-btn">Interact</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Canvas context not supported');
                alert('This browser does not support the canvas element. Please use a modern browser.');
                throw new Error('Canvas context not supported');
            }

            const gameContainer = document.getElementById('game-container');
            const dpr = window.devicePixelRatio || 1;
            const designWidth = 1900;
            const designHeight = 1000;

            let scaleX = 1, scaleY = 1, offsetX = 0, offsetY = 0;

            function resizeCanvas(attempts = 5, delay = 500) {
                try {
                    let containerWidth = gameContainer.clientWidth;
                    let containerHeight = gameContainer.clientHeight;

                    if (containerWidth <= 0 || containerHeight <= 0 || isNaN(containerWidth) || isNaN(containerHeight)) {
                        console.warn('Initial canvas resize failed, using fallback dimensions');
                        containerWidth = 1280;
                        containerHeight = 720;
                    }

                    if (containerWidth <= 0 || containerHeight <= 0 || isNaN(containerWidth) || isNaN(containerHeight)) {
                        if (attempts > 0) {
                            console.log('Invalid container dimensions (Width:', containerWidth, 'Height:', containerHeight, '), retrying... Attempts left:', attempts);
                            setTimeout(() => resizeCanvas(attempts - 1, delay), delay);
                            return false;
                        } else {
                            console.warn('Failed to get valid container dimensions after retries, keeping fallback size');
                            return false;
                        }
                    }

                    console.log('Resizing canvas - Width:', containerWidth, 'Height:', containerHeight, 'DPR:', dpr);

                    canvas.width = containerWidth * dpr;
                    canvas.height = containerHeight * dpr;
                    canvas.style.width = `${containerWidth}px`;
                    canvas.style.height = `${containerHeight}px`;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.scale(dpr, dpr);

                    const aspectRatio = designWidth / designHeight;
                    const containerAspectRatio = containerWidth / containerHeight;

                    if (containerAspectRatio > aspectRatio) {
                        scaleY = containerHeight / designHeight;
                        scaleX = scaleY;
                        offsetX = (containerWidth - designWidth * scaleX) / 2;
                        offsetY = 0;
                    } else {
                        scaleX = containerWidth / designWidth;
                        scaleY = scaleX;
                        offsetX = 0;
                        offsetY = (containerHeight - designHeight * scaleY) / 2;
                    }

                    // Scale game elements
                    player.x = 150 * scaleX;
                    player.y = 826 * scaleY;
                    player.width = 32 * scaleX * (window.innerWidth <= 767 ? 1.5 : 1);
                    player.height = 48 * scaleY * (window.innerWidth <= 767 ? 1.5 : 1);
                    player.speed = 4 * scaleX * (window.innerWidth <= 767 ? 1.2 : 1);
                    player.jumpPower = -16 * scaleY * (window.innerWidth <= 767 ? 1.3 : 1);
                    player.gravity = 0.6 * scaleY;

                    platforms.forEach(p => {
                        p.x = p.originalX * scaleX;
                        p.y = p.originalY * scaleY;
                        p.width = p.originalWidth * scaleX;
                        p.height = p.originalHeight * scaleY;
                    });

                    signs.forEach(s => {
                        s.x = s.originalX * scaleX;
                        s.y = s.originalY * scaleY;
                        s.width = s.originalWidth * scaleX;
                        s.height = s.originalHeight * scaleY;
                    });

                    locations.forEach(loc => {
                        loc.x = loc.originalX * scaleX;
                        loc.y = loc.originalY * scaleY;
                        loc.width = loc.originalWidth * scaleX;
                        loc.height = loc.originalHeight * scaleY;
                        loc.groundY = loc.originalGroundY * scaleY;
                    });

                    cars.forEach(car => {
                        car.x = car.originalX * scaleX;
                        car.y = car.originalY * scaleY;
                        car.width = car.originalWidth * scaleX;
                        car.height = car.originalHeight * scaleY;
                        car.speed = car.originalSpeed * scaleX;
                    });

                    train.x = train.originalX * scaleX;
                    train.y = train.originalY * scaleY;
                    train.width = train.originalWidth * scaleX;
                    train.height = train.originalHeight * scaleY;
                    train.speed = train.originalSpeed * scaleX;

                    stars.forEach(star => {
                        star.x = star.originalX * containerWidth;
                        star.y = star.originalY * containerHeight;
                        star.radius = star.originalRadius * scaleX;
                    });

                    distantBuildings.forEach(db => {
                        db.x = db.originalX * scaleX;
                        db.y = db.originalY * scaleY;
                        db.width = db.originalWidth * scaleX;
                        db.height = db.originalHeight * scaleY;
                    });

                    undergroundTrains.forEach(ut => {
                        ut.x = ut.originalX * scaleX;
                        ut.y = ut.originalY * scaleY;
                        ut.width = ut.originalWidth * scaleX;
                        ut.height = ut.originalHeight * scaleY;
                        ut.speed = ut.originalSpeed * scaleX;
                    });

                    undergroundSigns.forEach(us => {
                        us.x = us.originalX * scaleX;
                        us.y = us.originalY * scaleY;
                        us.width = us.originalWidth * scaleX;
                        us.height = us.originalHeight * scaleY;
                    });

                    neonArrows.forEach(na => {
                        na.x = na.originalX * scaleX;
                        na.y = na.originalY * scaleY;
                        na.width = na.originalWidth * scaleX;
                        na.height = na.originalHeight * scaleY;
                    });

                    console.log('Canvas resize successful - ScaleX:', scaleX, 'ScaleY:', scaleY, 'OffsetX:', offsetX, 'OffsetY:', offsetY);
                    return true;
                } catch (error) {
                    console.error('Error resizing canvas:', error.message, 'Stack:', error.stack);
                    if (attempts > 0) {
                        console.log('Retrying resize... Attempts left:', attempts);
                        setTimeout(() => resizeCanvas(attempts - 1, delay), delay);
                    } else {
                        console.warn('Failed to resize canvas after retries, keeping fallback size');
                    }
                    return false;
                }
            }

            // Initial canvas setup with fallback dimensions
            canvas.width = 1280 * dpr;
            canvas.height = 720 * dpr;
            canvas.style.width = '1280px';
            canvas.style.height = '720px';
            ctx.scale(dpr, dpr);

            // Delay initial resize to ensure DOM stability
            setTimeout(() => resizeCanvas(), 500);

            let resizeTimeout;
            function debouncedResize() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(resizeCanvas, 100);
            }

            window.addEventListener('resize', debouncedResize);
            window.addEventListener('orientationchange', debouncedResize);

            const player = {
                x: 150 * scaleX,
                y: 826 * scaleY,
                width: 32 * scaleX * (window.innerWidth <= 767 ? 1.5 : 1),
                height: 48 * scaleY * (window.innerWidth <= 767 ? 1.5 : 1),
                speed: 4 * scaleX * (window.innerWidth <= 767 ? 1.2 : 1),
                vy: 0,
                jumpPower: -16 * scaleY * (window.innerWidth <= 767 ? 1.3 : 1),
                gravity: 0.6 * scaleY,
                grounded: true
            };

            const playerImage = new Image();
            playerImage.src = 'player.png';
            playerImage.onload = () => {
                console.log('Player image loaded successfully');
            };
            playerImage.onerror = () => {
                console.error('Failed to load player image');
            };

            const platforms = [
                { originalX: 0, originalY: 850, originalWidth: 1900, originalHeight: 20 },
                { originalX: 100, originalY: 550, originalWidth: 1200, originalHeight: 20 },
                { originalX: 0, originalY: 250, originalWidth: 1200, originalHeight: 20 },
                { originalX: 1590, originalY: 850, originalWidth: 200, originalHeight: 20 },
                { originalX: 1590, originalY: 650, originalWidth: 200, originalHeight: 20 },
                { originalX: 1590, originalY: 450, originalWidth: 200, originalHeight: 20 },
                { originalX: 1590, originalY: 250, originalWidth: 200, originalHeight: 20 },
                { originalX: 100, originalY: 750, originalWidth: 50, originalHeight: 10 },
                { originalX: 900, originalY: 750, originalWidth: 50, originalHeight: 10 },
                { originalX: 100, originalY: 450, originalWidth: 50, originalHeight: 10 },
                { originalX: 900, originalY: 450, originalWidth: 50, originalHeight: 10 }
            ].map(p => ({
                ...p,
                x: p.originalX * scaleX,
                y: p.originalY * scaleY,
                width: p.originalWidth * scaleX,
                height: p.originalHeight * scaleY
            }));

            const signs = [
                { originalX: 190, originalY: 710, originalWidth: 20, originalHeight: 10, label: 'Intern at Cerno' },
                { originalX: 653, originalY: 710, originalWidth: 20, originalHeight: 10, label: 'Intern Accountant' },
                { originalX: 1116, originalY: 710, originalWidth: 20, originalHeight: 10, label: 'Payroll Officer RASHAYS' },
                { originalX: 1116, originalY: 510, originalWidth: 20, originalHeight: 10, label: 'Payroll Officer Consortio' },
                { originalX: 653, originalY: 510, originalWidth: 20, originalHeight: 10, label: 'Payroll Team Leader' },
                { originalX: 190, originalY: 510, originalWidth: 20, originalHeight: 10, label: 'Payroll Manager' },
                { originalX: 785, originalY: 210, originalWidth: 20, originalHeight: 10, label: 'Data Manager' },
                { originalX: 1640, originalY: 810, originalWidth: 20, originalHeight: 10, label: 'Hobbies' },
                { originalX: 1640, originalY: 610, originalWidth: 20, originalHeight: 10, label: 'Education' },
                { originalX: 1640, originalY: 410, originalWidth: 20, originalHeight: 10, label: 'Skills' },
                { originalX: 1640, originalY: 210, originalWidth: 20, originalHeight: 10, label: 'Projects' }
            ].map(s => ({
                ...s,
                x: s.originalX * scaleX,
                y: s.originalY * scaleY,
                width: s.originalWidth * scaleX,
                height: s.originalHeight * scaleY
            }));

            const resumeLocations = [
                { id: 'intern-cerno', title: 'Intern at Cerno', content: '<p>Mar 2013 – Jun 2013 | St. Leonards, Sydney</p><p>Responsibilities:</p><ul><li>Compared bank statements with Navision journals.</li><li>Checked invoice status and payment details.</li><li>Assisted with financial data verification.</li><li>Supported team with administrative tasks.</li></ul>', startYear: 2013, endYear: 2013, layer: 'bottom', originalX: 200, originalY: 790, originalWidth: 72, originalHeight: 72, originalGroundY: 850, timelineOrder: 1 },
                { id: 'intern-accountant', title: 'Intern Assistant Accountant', content: '<p>Feb 2015 – Nov 2015 | Surry Hills, Sydney</p><p>Responsibilities:</p><ul><li>Managed accounts payable/receivable using MYOB.</li><li>Reconciled bank accounts and payroll sheets.</li><li>Prepared Business Activity Statements (BAS).</li><li>Performed cost center analysis with Excel.</li></ul>', startYear: 2015, endYear: 2015, layer: 'bottom', originalX: 663, originalY: 780, originalWidth: 84, originalHeight: 84, originalGroundY: 850, timelineOrder: 2 },
                { id: 'payroll-officer-rashays', title: 'Payroll Officer at RASHAYS', content: '<p>Nov 2015 – Oct 2018 | Sydney, Australia</p><p>Responsibilities:</p><ul><li>Processed payroll for restaurant staff accurately.</li><li>Maintained employee records and leave balances.</li><li>Ensured compliance with payroll regulations.</li><li>Generated reports using Excel for management.</li></ul>', startYear: 2015, endYear: 2018, layer: 'bottom', originalX: 1126, originalY: 770, originalWidth: 96, originalHeight: 96, originalGroundY: 850, timelineOrder: 3 },
                { id: 'payroll-officer-consortio', title: 'Payroll Officer at Consortio', content: '<p>Oct 2018 – Mar 2021 | Sydney, Australia</p><p>Responsibilities:</p><ul><li>Ensured accurate salary disbursement and compliance.</li><li>Managed overpayment recovery and leave records.</li><li>Prepared reports within regulatory timeframes.</li><li>Used Excel and payroll systems for data tasks.</li></ul>', startYear: 2018, endYear: 2021, layer: 'middle', originalX: 1126, originalY: 490, originalWidth: 72, originalHeight: 72, originalGroundY: 550, timelineOrder: 4 },
                { id: 'payroll-team-leader', title: 'Payroll Team Leader at Consortio', content: '<p>Mar 2021 – Nov 2021 | Australia</p><p>Responsibilities:</p><ul><li>Led payroll team to ensure timely processing.</li><li>Implemented process improvements for efficiency.</li><li>Ensured data accuracy across payroll systems.</li><li>Supported compliance with payroll regulations.</li></ul>', startYear: 2021, endYear: 2021, layer: 'middle', originalX: 663, originalY: 480, originalWidth: 84, originalHeight: 84, originalGroundY: 550, timelineOrder: 5 },
                { id: 'payroll-manager', title: 'Payroll Manager at Consortio', content: '<p>Nov 2021 – Jun 2023 | Sydney, NSW, Australia</p><p>Responsibilities:</p><ul><li>Oversaw payroll processing for accuracy and compliance.</li><li>Developed reports using SQL and Excel for insights.</li><li>Streamlined payroll workflows with VBA automation.</li><li>Trained team on payroll systems and data tools.</li></ul>', startYear: 2021, endYear: 2023, layer: 'middle', originalX: 200, originalY: 470, originalWidth: 96, originalHeight: 96, originalGroundY: 550, timelineOrder: 6 },
                { id: 'data-manager', title: 'Data Manager at Consortio', content: '<p>Jul 2023 – Present | Sydney, NSW, Australia</p><p>Responsibilities:</p><ul><li>Led data strategy and analytics initiatives.</li><li>Built and maintained dashboards using Looker Studio.</li><li>Managed large datasets with SQL and Google BigQuery.</li><li>Collaborated with teams to drive data-driven decisions.</li></ul>', startYear: 2023, endYear: 'Present', layer: 'top', originalX: 795, originalY: 150, originalWidth: 108, originalHeight: 120, originalGroundY: 250, timelineOrder: 7, isPresent: true },
                { id: 'hobbies', title: 'Hobbies', content: '<p>Personal Interests:</p><ul><li>Coding personal projects in Python and JavaScript.</li><li>Hiking in national parks around Sydney.</li><li>Photography, focusing on landscapes and cityscapes.</li><li>Playing strategy board games with friends.</li></ul>', startYear: null, endYear: null, layer: 'bottom', originalX: 1650, originalY: 810, originalWidth: 96, originalHeight: 96, originalGroundY: 850, isIcon: true },
                { id: 'education', title: 'Education', content: '<p>Academic Background:</p><ul><li>Diploma in Accounting, Sydney TAFE, 2013.</li><li>Completed courses in SQL and Data Visualization.</li><li>Certified in Advanced Excel and VBA Programming.</li><li>Studied Business Analytics short course, UNSW, 2020.</li></ul>', startYear: null, endYear: null, layer: 'middle', originalX: 1650, originalY: 610, originalWidth: 96, originalHeight: 96, originalGroundY: 650, isIcon: true },
                { id: 'skills', title: 'Skills', content: '<p>Core Competencies:</p><ul><li>Data Analysis & Modeling</li><li>SQL & Google BigQuery</li><li>Looker Studio & Data Visualization</li><li>Microsoft Excel & VBA</li><li>Payroll Services & Data Management</li></ul>', startYear: null, endYear: null, layer: 'top', originalX: 1650, originalY: 410, originalWidth: 96, originalHeight: 96, originalGroundY: 450, isIcon: true },
                { id: 'projects', title: 'Projects', content: '<p>Key Achievements in Data Analytics:</p><ul><li>Built a dashboard app for payroll insights using Looker Studio.</li><li>Automated data cleaning with VBA scripts for Consortio.</li><li>Designed SQL queries for real-time reporting at RASHAYS.</li><li>Created predictive models for workforce planning.</li></ul>', startYear: null, endYear: null, layer: 'top', originalX: 1650, originalY: 154, originalWidth: 96, originalHeight: 96, originalGroundY: 250, isIcon: true },
                { id: 'achievements', title: 'Achievements', content: '<p>Career Highlights:</p><ul><li>Certified Data Analyst, 2023.</li><li>Streamlined payroll systems at Consortio, saving 20% time.</li><li>Completed over 100 dashboards for business insights.</li><li>Mentored payroll team to improve accuracy.</li></ul>', startYear: null, endYear: null, layer: 'top', originalX: 890, originalY: 210, originalWidth: 50, originalHeight: 50, originalGroundY: 250, locked: true }
            ].map(loc => ({
                ...loc,
                x: loc.originalX * scaleX,
                y: loc.originalY * scaleY,
                width: loc.originalWidth * scaleX,
                height: loc.originalHeight * scaleY,
                groundY: loc.originalGroundY * scaleY
            }));

            const locations = resumeLocations.map(loc => ({
                ...loc,
                radiating: false,
                pulseVisited: false,
                draw: loc.isIcon ? drawIcon : drawBuilding,
                tooltip: loc.startYear ? `${loc.startYear}${loc.endYear === 'Present' ? '–Present' : loc.endYear ? '–' + loc.endYear : ''}: ${loc.title}` : loc.title
            }));

            const popupsContainer = document.getElementById('popups-container');
            locations.forEach(loc => {
                const popup = document.createElement('div');
                popup.className = 'popup';
                popup.id = loc.id + '-popup';
                popup.innerHTML = `
                    <button class="close-btn" onclick="closePopup('${loc.id}-popup')">×</button>
                    <h2>${loc.title}</h2>
                    ${loc.content}
                `;
                popupsContainer.appendChild(popup);
            });

            const cars = [
                { originalX: 0, originalY: 980, originalWidth: 50, originalHeight: 20, originalSpeed: 2.5, color: '#FF4040' },
                { originalX: 400, originalY: 980, originalWidth: 50, originalHeight: 20, originalSpeed: -2, color: '#32CD32' },
                { originalX: 200, originalY: 960, originalWidth: 50, originalHeight: 20, originalSpeed: 2, color: '#FF69B4' },
                { originalX: 600, originalY: 940, originalWidth: 50, originalHeight: 20, originalSpeed: -1.5, color: '#00CED1' }
            ].map(car => ({
                ...car,
                x: car.originalX * scaleX,
                y: car.originalY * scaleY,
                width: car.originalWidth * scaleX,
                height: car.originalHeight * scaleY,
                speed: car.originalSpeed * scaleX
            }));

            const train = { originalX: 0, originalY: 350, originalWidth: 120, originalHeight: 25, originalSpeed: 2, color: '#A3BFFA' };
            train.x = train.originalX * scaleX;
            train.y = train.originalY * scaleY;
            train.width = train.originalWidth * scaleX;
            train.height = train.originalHeight * scaleY;
            train.speed = train.originalSpeed * scaleX;

            const stars = Array.from({ length: 100 }, () => {
                const x = Math.random();
                const y = Math.random() * 0.3;
                return {
                    originalX: x,
                    originalY: y,
                    x: x * gameContainer.clientWidth,
                    y: y * gameContainer.clientHeight,
                    originalRadius: Math.random() * 2,
                    radius: Math.random() * 2 * scaleX,
                    opacity: Math.random()
                };
            });

            const distantBuildings = [
                { originalX: 0, originalY: 800, originalWidth: 50, originalHeight: 70 },
                { originalX: 70, originalY: 800, originalWidth: 40, originalHeight: 80 },
                { originalX: 130, originalY: 800, originalWidth: 60, originalHeight: 60 },
                { originalX: 900, originalY: 800, originalWidth: 50, originalHeight: 70 },
                { originalX: 970, originalY: 800, originalWidth: 30, originalHeight: 90 },
                { originalX: 1020, originalY: 800, originalWidth: 40, originalHeight: 60 }
            ].map(db => ({
                ...db,
                x: db.originalX * scaleX,
                y: db.originalY * scaleY,
                width: db.originalWidth * scaleX,
                height: db.originalHeight * scaleY
            }));

            const undergroundTrains = [
                { originalX: 0, originalY: 890, originalWidth: 100, originalHeight: 25, originalSpeed: 1.2 },
                { originalX: 300, originalY: 920, originalWidth: 100, originalHeight: 25, originalSpeed: -1 },
                { originalX: 600, originalY: 950, originalWidth: 100, originalHeight: 25, originalSpeed: 0.8 }
            ].map(ut => ({
                ...ut,
                x: ut.originalX * scaleX,
                y: ut.originalY * scaleY,
                width: ut.originalWidth * scaleX,
                height: ut.originalHeight * scaleY,
                speed: ut.originalSpeed * scaleX
            }));

            const undergroundSigns = [
                { originalX: 150, originalY: 880, originalWidth: 20, originalHeight: 10, label: 'Metro' },
                { originalX: 400, originalY: 880, originalWidth: 20, originalHeight: 10, label: 'Station' },
                { originalX: 650, originalY: 880, originalWidth: 20, originalHeight: 10, label: 'Exit' }
            ].map(us => ({
                ...us,
                x: us.originalX * scaleX,
                y: us.originalY * scaleY,
                width: us.originalWidth * scaleX,
                height: us.originalHeight * scaleY
            }));

            const neonArrows = [
                { originalX: 50, originalY: 800, originalWidth: 60, originalHeight: 30 },
                { originalX: 50, originalY: 500, originalWidth: 60, originalHeight: 30 },
                { originalX: 50, originalY: 200, originalWidth: 60, originalHeight: 30 }
            ].map(na => ({
                ...na,
                x: na.originalX * scaleX,
                y: na.originalY * scaleY,
                width: na.originalWidth * scaleX,
                height: na.originalHeight * scaleY
            }));

            function drawBuilding(x, y, width, height, tooltip, groundY, isPresent, loc) {
                const baseY = groundY - height;
                ctx.save();
                const gradient = ctx.createLinearGradient(x + offsetX, baseY + offsetY, x + offsetX, baseY + height + offsetY);
                gradient.addColorStop(0, '#2A2A3A');
                gradient.addColorStop(1, '#3A3A4A');
                ctx.fillStyle = gradient;
                ctx.strokeStyle = '#00DDEB';
                ctx.lineWidth = 0.5 * scaleX;

                try {
                    ctx.beginPath();
                    if (loc.id === 'intern-cerno') {
                        ctx.moveTo(x + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#00DDEB';
                        ctx.fillRect(x + offsetX + width / 2 - 2 * scaleX, baseY + offsetY - 10 * scaleY, 4 * scaleX, 10 * scaleY);
                    } else if (loc.id === 'intern-accountant') {
                        ctx.moveTo(x + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + 10 * scaleY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (loc.id === 'payroll-officer-rashays') {
                        ctx.moveTo(x + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.quadraticCurveTo(x + width / 2 + offsetX, baseY + offsetY, x + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (loc.id === 'payroll-officer-consortio') {
                        ctx.moveTo(x + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#00DDEB';
                        ctx.fillRect(x + offsetX + width / 2 - 5 * scaleX, baseY + offsetY - 5 * scaleY, 10 * scaleX, (Math.random() * (10 - 5) + 5) * scaleY);
                    } else if (loc.id === 'payroll-team-leader') {
                        ctx.moveTo(x + offsetX, baseY + 5 * scaleY + offsetY);
                        ctx.lineTo(x + width / 2 + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + 5 * scaleY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (loc.id === 'payroll-manager') {
                        ctx.moveTo(x + 5 * scaleX + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width - 5 * scaleX + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (loc.id === 'data-manager') {
                        ctx.moveTo(x + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.quadraticCurveTo(x + width / 2 + offsetX, baseY - 10 * scaleY + offsetY, x + offsetX, baseY + 20 * scaleY + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.moveTo(x + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + offsetY);
                        ctx.lineTo(x + width + offsetX, baseY + height + offsetY);
                        ctx.lineTo(x + offsetX, baseY + height + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#00DDEB';
                        ctx.fillRect(x + offsetX + width / 2 - 3 * scaleX, baseY + offsetY - 5 * scaleY, 6 * scaleX, 5 * scaleY);
                    }

                    const rows = height >= 80 * scaleY ? 8 : 6;
                    const cols = 4;
                    const windowWidth = 8 * scaleX * (window.innerWidth <= 767 ? 1.3 : 1);
                    const windowHeight = 6 * scaleY * (window.innerWidth <= 767 ? 1.3 : 1);
                    let offsetYLocal = height >= 80 * scaleY ? 20 * scaleY : 16 * scaleY;
                    if (loc.id === 'intern-cerno') offsetYLocal = 18 * scaleY;
                    if (loc.id === 'payroll-officer-consortio') offsetYLocal = 14 * scaleY;
                    if (loc.id === 'payroll-officer-rashays') offsetYLocal = 24 * scaleY;
                    const offsetXLocal = (width - cols * windowWidth - (cols - 1) * 2 * scaleX) / 2;
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            let yPos = baseY + offsetY + offsetYLocal + i * (windowHeight + 2 * scaleY);
                            if (loc.id === 'intern-accountant') {
                                yPos += ((cols - 1 - j) / (cols - 1)) * 10 * scaleY;
                            } else if (loc.id === 'payroll-officer-rashays' && i === 0) {
                                yPos += Math.abs(j - 1.5) * 4 * scaleY;
                            } else if (loc.id === 'payroll-manager') {
                                const taperOffset = (cols - 1 - j) < cols / 2 ? (cols - 1 - j) : j;
                                yPos += (taperOffset * 2 * scaleY);
                            }
                            if (yPos + windowHeight <= groundY + offsetY) {
                                ctx.fillStyle = '#00DDEB';
                                ctx.fillRect(
                                    x + offsetX + offsetXLocal + j * (windowWidth + 2 * scaleX),
                                    yPos,
                                    windowWidth,
                                    windowHeight
                                );
                                ctx.strokeStyle = '#FFFFFF';
                                ctx.lineWidth = 0.5 * scaleX;
                                ctx.strokeRect(
                                    x + offsetX + offsetXLocal + j * (windowWidth + 2 * scaleX),
                                    yPos,
                                    windowWidth,
                                    windowHeight
                                );
                            }
                        }
                    }

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(x + offsetX + 5 * scaleX, groundY + offsetY, width, 5 * scaleY);

                    if (isPresent) {
                        ctx.strokeStyle = '#00DDEB';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.lineWidth = 4 * scaleX;
                        ctx.strokeRect(x + offsetX - 2 * scaleX, baseY + offsetY - 2 * scaleY, width + 4 * scaleX, height + 4 * scaleY);
                        ctx.globalAlpha = 1;
                    }
                    if (loc.pulseVisited && !isPresent) {
                        ctx.strokeStyle = '#00DDEB';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.lineWidth = 2 * scaleX;
                        ctx.strokeRect(x + offsetX - 1 * scaleX, baseY + offsetY - 1 * scaleY, width + 2 * scaleX, height + 2 * scaleY);
                        ctx.globalAlpha = 1;
                    }
                } catch (error) {
                    console.error(`Error drawing building ${loc.id}:`, error);
                    ctx.fillRect(x + offsetX, baseY + offsetY, width, height);
                    ctx.strokeRect(x + offsetX, baseY + offsetY, width, height);
                }
                ctx.restore();
            }

            function drawIcon(x, y, width, height, tooltip, groundY, isPresent, loc) {
                const baseY = groundY - height;
                ctx.save();
                const gradient = ctx.createLinearGradient(x + offsetX, baseY + offsetY, x + offsetX, baseY + height + offsetY);
                gradient.addColorStop(0, '#00DDEB');
                gradient.addColorStop(1, '#00A3B0');
                ctx.fillStyle = gradient;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 * scaleX;

                try {
                    ctx.beginPath();
                    if (loc.id === 'hobbies') {
                        const heartSize = width * 0.8;
                        const cx = x + offsetX + width / 2;
                        const cy = baseY + offsetY + height / 2;
                        ctx.moveTo(cx, cy - heartSize / 4);
                        ctx.bezierCurveTo(
                            cx + heartSize / 2, cy - heartSize / 2,
                            cx + heartSize / 2, cy + heartSize / 4,
                            cx, cy + heartSize / 2
                        );
                        ctx.bezierCurveTo(
                            cx - heartSize / 2, cy + heartSize / 4,
                            cx - heartSize / 2, cy - heartSize / 2,
                            cx, cy - heartSize / 4
                        );
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#FFFFFF';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.beginPath();
                        ctx.arc(cx + heartSize / 3, cy - heartSize / 3, 3 * scaleX, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    } else if (loc.id === 'education') {
                        ctx.moveTo(x + offsetX + width * 0.2, baseY + offsetY);
                        ctx.lineTo(x + offsetX + width * 0.8, baseY + offsetY);
                        ctx.lineTo(x + offsetX + width * 0.8, baseY + height * 0.7 + offsetY);
                        ctx.quadraticCurveTo(x + offsetX + width / 2, baseY + height + offsetY, x + offsetX + width * 0.2, baseY + height * 0.7 + offsetY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1 * scaleX;
                        ctx.beginPath();
                        ctx.moveTo(x + offsetX + width * 0.3, baseY + offsetY + height * 0.4);
                        ctx.lineTo(x + offsetX + width * 0.7, baseY + offsetY + height * 0.4);
                        ctx.moveTo(x + offsetX + width * 0.3, baseY + offsetY + height * 0.5);
                        ctx.lineTo(x + offsetX + width * 0.7, baseY + offsetY + height * 0.5);
                        ctx.stroke();
                    } else if (loc.id === 'skills') {
                        const cx = x + offsetX + width / 2;
                        const cy = baseY + offsetY + height / 2;
                        const r = width * 0.4;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI) / 4;
                            const innerR = r * 0.7;
                            const outerR = r * 1.2;
                            ctx.lineTo(cx + Math.cos(angle) * innerR, cy + Math.sin(angle) * innerR);
                            ctx.lineTo(cx + Math.cos(angle + Math.PI / 8) * outerR, cy + Math.sin(angle + Math.PI / 8) * outerR);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(cx, cy, 5 * scaleX, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (loc.id === 'projects') {
                        const cx = x + offsetX + width / 2;
                        const cy = baseY + offsetY + height * 0.7;
                        ctx.arc(cx, cy, width * 0.3, 0, Math.PI * 2);
                        ctx.moveTo(cx - width * 0.1, cy + width * 0.3);
                        ctx.lineTo(cx - width * 0.1, cy + width * 0.5);
                        ctx.lineTo(cx + width * 0.1, cy + width * 0.5);
                        ctx.lineTo(cx + width * 0.1, cy + width * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#FF4040';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.beginPath();
                        ctx.moveTo(cx - width * 0.2, cy);
                        ctx.lineTo(cx - width * 0.4, cy + width * 0.2);
                        ctx.lineTo(cx - width * 0.2, cy + width * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(x + offsetX + 5 * scaleX, groundY + offsetY, width, 5 * scaleY);

                    ctx.strokeStyle = '#00DDEB';
                    ctx.globalAlpha = pulseOpacity;
                    ctx.lineWidth = 3 * scaleX;
                    ctx.strokeRect(x + offsetX - 2 * scaleX, baseY + offsetY - 2 * scaleY, width + 4 * scaleX, height + 4 * scaleY);
                    ctx.globalAlpha = 1;

                    if (isPresent) {
                        ctx.strokeStyle = '#00DDEB';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.lineWidth = 4 * scaleX;
                        ctx.strokeRect(x + offsetX - 2 * scaleX, baseY + offsetY - 2 * scaleY, width + 4 * scaleX, height + 4 * scaleY);
                        ctx.globalAlpha = 1;
                    }
                    if (loc.pulseVisited && !isPresent) {
                        ctx.strokeStyle = '#00DDEB';
                        ctx.globalAlpha = pulseOpacity;
                        ctx.lineWidth = 2 * scaleX;
                        ctx.strokeRect(x + offsetX - 1 * scaleX, baseY + offsetY - 1 * scaleY, width + 2 * scaleX, height + 2 * scaleY);
                        ctx.globalAlpha = 1;
                    }
                } catch (error) {
                    console.error(`Error drawing icon ${loc.id}:`, error);
                    ctx.fillRect(x + offsetX, baseY + offsetY, width, height);
                    ctx.strokeRect(x + offsetX, baseY + offsetY, width, height);
                }
                ctx.restore();
            }

            function drawCar(car) {
                ctx.save();
                ctx.fillStyle = car.color;
                ctx.fillRect(car.x + offsetX, car.y + offsetY, car.width, car.height);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(car.x + offsetX + 6 * scaleX, car.y + offsetY + 3 * scaleY, 10 * scaleX, 6 * scaleY);
                ctx.fillRect(car.x + offsetX + 34 * scaleX, car.y + offsetY + 3 * scaleY, 10 * scaleX, 6 * scaleY);
                ctx.restore();
            }

            function drawTrain(train) {
                ctx.save();
                ctx.fillStyle = train.color;
                ctx.fillRect(train.x + offsetX, train.y + offsetY, train.width, train.height);
                ctx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(train.x + offsetX + 12 * scaleX + i * 36 * scaleX, train.y + offsetY + 3 * scaleY, 12 * scaleX, 12 * scaleY);
                }
                ctx.restore();
            }

            function drawUndergroundTrain(train) {
                ctx.save();
                ctx.fillStyle = '#FF8C00';
                ctx.fillRect(train.x + offsetX, train.y + offsetY, train.width, train.height);
                ctx.fillStyle = '#FFFFE0';
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(train.x + offsetX + 12 * scaleX + i * 36 * scaleX, train.y + offsetY + 3 * scaleY, 12 * scaleX, 12 * scaleY);
                }
                ctx.restore();
            }

            function drawSign(sign) {
                ctx.save();
                ctx.font = `${14 * scaleX}px Inter`;
                ctx.fillStyle = '#FFFFFF';
                ctx.globalAlpha = Math.sin(Date.now() / 500) * 0.3 + 0.7;
                ctx.fillText(sign.label, sign.x + offsetX + 2 * scaleX, sign.y + offsetY + 1 * scaleY);
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            function drawDistantBuilding(building) {
                ctx.save();
                ctx.fillStyle = '#1E3A5F';
                ctx.fillRect(building.x + offsetX, building.y + offsetY - building.height, building.width, building.height);
                ctx.restore();
            }

            function drawNeonArrow(arrow) {
                ctx.save();
                ctx.fillStyle = '#00DDEB';
                ctx.globalAlpha = pulseOpacity;
                ctx.beginPath();
                const cx = arrow.x + offsetX + arrow.width / 2;
                const cy = arrow.y + offsetY + arrow.height / 2;
                ctx.moveTo(arrow.x + offsetX, cy);
                ctx.lineTo(arrow.x + offsetX + arrow.width - 10 * scaleX, cy);
                ctx.lineTo(arrow.x + offsetX + arrow.width - 10 * scaleX, cy - 10 * scaleY);
                ctx.lineTo(arrow.x + offsetX + arrow.width, cy);
                ctx.lineTo(arrow.x + offsetX + arrow.width - 10 * scaleX, cy + 10 * scaleY);
                ctx.lineTo(arrow.x + offsetX + arrow.width - 10 * scaleX, cy);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1 * scaleX;
                ctx.globalAlpha = pulseOpacity * 0.7;
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            let xp = 0;
            const visited = new Set();
            let achievementsUnlocked = false;
            let pulseOpacity = 0.4;
            let pulseDirection = 1;
            let nearestLoc = null;
            let minDistance = Infinity;

            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            document.body.appendChild(tooltip);

            const keys = {};
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                if (e.code === 'Space' && player.grounded) {
                    player.vy = player.jumpPower;
                    player.grounded = false;
                }
                if (e.code === 'Enter') {
                    checkInteraction();
                }
                if (e.code === 'Escape') closeAllPopups();
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');
            const jumpBtn = document.getElementById('jump-btn');
            const interactBtn = document.getElementById('interact-btn');

            leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['a'] = true; });
            leftBtn.addEventListener('touchend', () => keys['a'] = false);
            rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['d'] = true; });
            rightBtn.addEventListener('touchend', () => keys['d'] = false);
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (player.grounded) {
                    player.vy = player.jumpPower;
                    player.grounded = false;
                }
            });
            interactBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                checkInteraction();
            });

            function update() {
                try {
                    console.log('Update loop running');
                    console.log('Canvas dimensions - Width:', canvas.width / dpr, 'Height:', canvas.height / dpr);

                    let isMoving = false;
                    if (keys['arrowleft'] || keys['a']) {
                        player.x -= player.speed;
                        isMoving = true;
                    }
                    if (keys['arrowright'] || keys['d']) {
                        player.x += player.speed;
                        isMoving = true;
                    }

                    player.vy += player.gravity;
                    player.y += player.vy;

                    player.grounded = false;
                    const allPlatforms = [
                        ...platforms,
                        ...locations.map(loc => ({
                            x: loc.x,
                            y: loc.groundY - loc.height,
                            width: loc.width,
                            height: loc.height
                        })),
                        ...cars.map(car => ({
                            x: car.x,
                            y: car.y,
                            width: car.width,
                            height: car.height
                        })),
                        { x: train.x, y: train.y, width: train.width, height: train.height }
                    ];

                    allPlatforms.forEach(platform => {
                        if (
                            player.x + player.width > platform.x &&
                            player.x < platform.x + platform.width &&
                            player.y + player.height > platform.y &&
                            player.y + player.height - player.vy <= platform.y &&
                            player.vy >= 0
                        ) {
                            player.y = platform.y - player.height;
                            player.vy = 0;
                            player.grounded = true;
                        }
                    });

                    player.x = Math.max(0, Math.min(designWidth * scaleX - player.width, player.x));
                    player.y = Math.min(850 * scaleY - player.height, player.y);

                    pulseOpacity += pulseDirection * 0.02;
                    if (pulseOpacity >= 0.8 || pulseOpacity <= 0.4) pulseDirection *= -1;

                    cars.forEach(car => {
                        car.x += car.speed;
                        if (car.x > designWidth * scaleX) car.x = -car.width;
                        if (car.x + car.width < 0) car.x = designWidth * scaleX;
                    });
                    train.x += train.speed;
                    if (train.x > designWidth * scaleX) train.x = -train.width;
                    if (train.x + train.width < 0) train.x = designWidth * scaleX;
                    undergroundTrains.forEach(train => {
                        train.x += train.speed;
                        if (train.x > designWidth * scaleX) train.x = -train.width;
                        if (train.x + train.width < 0) train.x = designWidth * scaleX;
                    });
                    stars.forEach(star => {
                        star.opacity = (star.opacity + 0.01) % 1;
                    });

                    const isPopupActive = Array.from(document.querySelectorAll('.popup, .welcome-popup')).some(p => p.classList.contains('active'));
                    canvas.classList.toggle('blur', isPopupActive);

                    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / dpr);
                    gradient.addColorStop(0, '#14141E');
                    gradient.addColorStop(0.8, '#1E3A5F');
                    gradient.addColorStop(1, '#3A3A4A');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);

                    stars.forEach(star => {
                        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    distantBuildings.forEach(drawDistantBuilding);

                    ctx.fillStyle = '#3A3A4A';
                    ctx.fillRect(offsetX, 340 * scaleY + offsetY, designWidth * scaleX, 6 * scaleY);
                    ctx.fillStyle = '#00DDEB';
                    ctx.fillRect(offsetX, 346 * scaleY + offsetY, designWidth * scaleX, 6 * scaleY);

                    neonArrows.forEach(drawNeonArrow);

                    drawTrain(train);

                    ctx.fillStyle = '#3A3A4A';
                    platforms.forEach(platform => {
                        ctx.fillRect(platform.x + offsetX, platform.y + offsetY, platform.width, platform.height);
                        ctx.strokeStyle = '#00DDEB';
                        ctx.lineWidth = 2 * scaleX;
                        ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 800) * 0.3;
                        ctx.strokeRect(platform.x + offsetX, platform.y + offsetY, platform.width, platform.height);
                        ctx.globalAlpha = 1;
                    });

                    cars.forEach(drawCar);

                    nearestLoc = null;
                    minDistance = Infinity;
                    locations.forEach((loc, index) => {
                        if (loc.locked && !achievementsUnlocked) return;
                        const dx = player.x + player.width / 2 - (loc.x + loc.width / 2);
                        const dy = player.y + player.height / 2 - (loc.groundY - loc.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const isNear = distance < 60 * scaleX;

                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestLoc = loc;
                        }

                        loc.draw(loc.x, loc.groundY, loc.width, loc.height, loc.tooltip, loc.groundY, loc.isPresent, loc);

                        if (isNear && !visited.has(loc.id) && !loc.locked) {
                            xp += 10;
                            visited.add(loc.id);
                            loc.pulseVisited = true;
                            if (xp >= 100 && !achievementsUnlocked) {
                                achievementsUnlocked = true;
                                locations.find(l => l.id === 'achievements').locked = false;
                                document.getElementById('achievements-popup').classList.add('active');
                            }
                        }
                        if (visited.has(loc.id) && !loc.pulseVisited) {
                            loc.pulseVisited = true;
                        }
                    });

                    signs.forEach(drawSign);

                    ctx.font = `${20 * scaleX}px Inter`;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText('2013–2017', 20 * scaleX + offsetX, 820 * scaleY + offsetY);
                    ctx.fillText('Early Career', 20 * scaleX + offsetX, 840 * scaleY + offsetY);
                    ctx.fillText('2018–2022', 20 * scaleX + offsetX, 450 * scaleY + offsetY);
                    ctx.fillText('Mid Career', 20 * scaleX + offsetX, 470 * scaleY + offsetY);
                    ctx.fillText('2023–Present', 20 * scaleX + offsetX, 150 * scaleY + offsetY);
                    ctx.fillText('Current Role', 20 * scaleX + offsetX, 170 * scaleY + offsetY);

                    ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
                    ctx.fillRect(offsetX, 850 * scaleY + offsetY, designWidth * scaleX, 200 * scaleY);
                    ctx.fillStyle = '#3A3A4A';
                    ctx.fillRect(offsetX, 850 * scaleY + offsetY, designWidth * scaleX, 200 * scaleY);
                    for (let y = 890 * scaleY; y <= 950 * scaleY; y += 30 * scaleY) {
                        ctx.fillStyle = '#2A2A3A';
                        ctx.fillRect(offsetX, y + offsetY - 6 * scaleY, designWidth * scaleX, 3 * scaleY);
                        ctx.fillStyle = '#FFC107';
                        ctx.fillRect(offsetX, y + offsetY - 3 * scaleY, designWidth * scaleX, 3 * scaleY);
                    }
                    undergroundTrains.forEach(drawUndergroundTrain);
                    undergroundSigns.forEach(drawSign);
                    for (let x = 60 * scaleX; x < designWidth * scaleX; x += 120 * scaleX) {
                        ctx.fillStyle = '#FFFFE0';
                        ctx.beginPath();
                        ctx.arc(x + offsetX, 870 * scaleY + offsetY, 6 * scaleX, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.font = `${22 * scaleX}px Inter`;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(`XP: ${xp}/100`, 20 * scaleX + offsetX, 30 * scaleY + offsetY);

                    const progressFill = document.getElementById('progress-fill');
                    const progressPercent = (visited.size / (locations.length - 1)) * 100;
                    progressFill.style.width = `${progressPercent}%`;

                    if (nearestLoc && minDistance < 120 * scaleX) {
                        tooltip.style.display = 'block';
                        tooltip.textContent = nearestLoc.tooltip;
                        tooltip.style.left = `${(nearestLoc.x + offsetX + nearestLoc.width + 12 * scaleX) / scaleX}px`;
                        tooltip.style.top = `${(nearestLoc.groundY - nearestLoc.height + offsetY) / scaleY}px`;
                    } else {
                        tooltip.style.display = 'none';
                    }

                    if (playerImage.complete && playerImage.naturalHeight !== 0) {
                        ctx.drawImage(playerImage, player.x + offsetX, player.y + offsetY, player.width, player.height);
                    } else {
                        ctx.fillStyle = '#FFDAB9';
                        ctx.fillRect(player.x + offsetX + 8 * scaleX, player.y + offsetY + 8 * scaleY, 16 * scaleX, 16 * scaleY);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(player.x + offsetX + 8 * scaleX, player.y + offsetY + 8 * scaleY, 16 * scaleX, 8 * scaleY);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(player.x + offsetX + 8 * scaleX, player.y + offsetY + 24 * scaleY, 16 * scaleX, 24 * scaleY);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(player.x + offsetX + 12 * scaleX, player.y + offsetY + 24 * scaleY, 8 * scaleX, 16 * scaleY);
                        ctx.fillStyle = '#00DDEB';
                        ctx.fillRect(player.x + offsetX + 14 * scaleX, player.y + offsetY + 32 * scaleY, 4 * scaleX, 8 * scaleY);
                    }

                    requestAnimationFrame(update);
                } catch (error) {
                    console.error('Error in update loop:', error);
                    alert('An error occurred in the game loop. Please check the console for details.');
                }
            }

            function checkInteraction() {
                locations.forEach(loc => {
                    if (loc.locked && !achievementsUnlocked) return;
                    const dx = player.x + player.width / 2 - (loc.x + loc.width / 2);
                    const dy = player.y + player.height / 2 - (loc.groundY - loc.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 60 * scaleX) {
                        const popup = document.getElementById(loc.id + '-popup');
                        if (popup) {
                            popup.classList.add('active');
                        } else {
                            console.error(`Popup for ${loc.id} not found`);
                        }
                    }
                });
            }

            if (gameContainer.clientWidth > 0 && gameContainer.clientHeight > 0) {
                update();
            } else {
                setTimeout(() => {
                    if (gameContainer.clientWidth > 0 && gameContainer.clientHeight > 0) {
                        update();
                    } else {
                        console.error('Game container has invalid dimensions:', gameContainer.clientWidth, gameContainer.clientHeight);
                        alert('Unable to initialize game due to invalid container dimensions.');
                    }
                }, 1000);
            }
        });
    </script>
</body>
</html>