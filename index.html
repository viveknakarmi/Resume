<script type="text/javascript">
        // Potentially required by hosting platform (e.g., Google Sites Gadget)
        // Defines helper functions for loading data (CSV/XLSX)
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error("Error processing XLSX file:", e); // Added console error
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Ensure proper rendering and touch zooming capabilities -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Interactive Resume City</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset and Global Box Sizing */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%; /* Ensure body takes full height */
            overflow: hidden; /* Prevent scrolling of the entire page */
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #14141E, #1E3A5F);
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Full viewport height */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming on the body/canvas */
        }

        #game-container {
            position: relative;
            width: 100vw; /* Full viewport width */
            height: 85vh; /* Adjusted height to leave space for potential mobile browser bars */
            /* Max width/height can be added for very large screens if needed */
            /* max-width: 1920px; */
            /* max-height: 1080px; */
            border: 2px solid #00DDEB;
            border-radius: 8px;
            overflow: hidden; /* Crucial to contain the canvas */
            background: rgba(20, 20, 30, 0.9);
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Keep pixel art sharp */
            transition: filter 0.3s ease;
        }

        #game-canvas.blur {
            filter: blur(3px); /* Blur effect when popup is active */
        }

        .popup, .welcome-popup { /* Combined styles for popups */
            display: none; /* Hidden by default */
            position: fixed;
            top: 70%; /* Start position for animation */
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #00DDEB;
            border-radius: 8px;
            padding: 1.5rem;
            width: 85vw; /* Responsive width */
            max-width: 450px; /* Max width for readability */
            min-height: 150px; /* Minimum height */
            max-height: 70vh; /* Max height to prevent overflow */
            overflow-y: auto; /* Enable scrolling for content */
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 221, 235, 0.5);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease, top 0.3s ease;
        }

        .popup.active, .welcome-popup.active { /* Style for active popups */
            display: block;
            top: 50%; /* Center position */
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .popup:hover, .welcome-popup:hover {
             /* Optional subtle hover effect */
            /* transform: translate(-50%, -50%) scale(1.02); */
        }

        .popup h2, .welcome-popup h2 {
            color: #FFFFFF;
            font-size: 1.6rem; /* Slightly smaller for mobile */
            margin: 0 0 0.8rem;
            font-weight: 700;
        }

        .popup p, .popup li, .welcome-popup p {
            color: #A3BFFA;
            font-size: 0.95rem; /* Adjusted for mobile */
            line-height: 1.6;
            text-align: left;
        }

        .popup ul {
            list-style: disc;
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        .popup a, .welcome-popup a {
            color: #00DDEB;
            text-decoration: none;
        }

        .popup a:hover, .welcome-popup a:hover {
            text-decoration: underline;
        }

        .close-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #FFFFFF;
            font-size: 1.8rem; /* Larger tap target */
            cursor: pointer;
            padding: 0.3rem; /* Add padding for easier tap */
            line-height: 1; /* Ensure consistent alignment */
            transition: color 0.2s ease;
        }

        .close-btn:hover {
            color: #00DDEB;
        }

        /* Desktop Instructions */
        .instructions {
            text-align: center;
            margin-top: 1rem; /* More space */
            font-size: 1rem;
            color: #A3BFFA;
            position: absolute; /* Position relative to body */
            bottom: 10px;
            width: 100%;
            display: block; /* Visible by default */
        }

        /* Mobile Instructions (initially hidden) */
        .instructions-mobile {
            display: none; /* Hidden by default */
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #A3BFFA;
            position: absolute; /* Position relative to body */
            bottom: 80px; /* Position above controls */
            width: 100%;
        }

        .progress-bar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 12px;
            background: #2A2A3A;
            border: 1px solid #00DDEB;
            border-radius: 4px;
            z-index: 5; /* Ensure it's above canvas but below popups */
        }

        .progress-fill {
            height: 100%;
            background: #00DDEB;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .button-container {
            position: absolute;
            top: 10px;
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Fine-tune centering */
            display: flex;
            justify-content: center;
            width: auto; /* Let content determine width */
            z-index: 15; /* Above progress bar */
        }

        .timeline-link {
            background: #00DDEB;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            color: #14141E;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            transition: background 0.2s ease;
            margin: 0 0.5rem;
            white-space: nowrap; /* Prevent wrapping */
        }

        .timeline-link:hover {
            background: #00B7C2;
        }

        .tooltip {
            position: absolute; /* Positioned by JS */
            background: rgba(0, 221, 235, 0.95); /* Slightly more opaque */
            color: #14141E;
            padding: 0.4rem 0.6rem; /* Adjust padding */
            border-radius: 4px;
            font-size: 0.85rem; /* Adjust font size */
            pointer-events: none; /* Doesn't interfere with clicks */
            z-index: 50; /* Above everything except popups maybe */
            display: none; /* Hidden by default */
            white-space: nowrap; /* Prevent wrapping */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Optional shadow */
        }

        /* Touch Controls Styling */
        .controls {
            position: fixed; /* Fixed at the bottom */
            bottom: 0;
            left: 0;
            width: 100vw;
            display: none; /* Hidden by default, shown via media query */
            justify-content: space-between;
            padding: 10px 15px; /* Add padding */
            z-index: 15; /* Above game canvas */
            background: rgba(20, 20, 30, 0.5); /* Optional semi-transparent background */
        }

        .control-btn {
            background: #00DDEB;
            color: #14141E;
            border: none;
            border-radius: 8px;
            padding: 15px; /* Generous padding for tap */
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.8;
            touch-action: manipulation; /* Optimize for touch taps */
            user-select: none; /* Prevent text selection on hold */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }

        .control-btn:active {
            opacity: 1;
            transform: scale(0.95);
        }

        .left-right, .actions {
            display: flex;
            gap: 20px; /* Space between buttons */
        }

        /* Media Query for Desktop */
        @media (min-width: 768px) {
            .controls {
                display: none; /* Hide touch controls */
            }
            .instructions {
                display: block; /* Show desktop instructions */
            }
            .instructions-mobile {
                display: none; /* Hide mobile instructions */
            }
            #game-container {
                /* Adjust size for larger screens, leaving some margin */
                width: calc(100vw - 40px);
                height: calc(100vh - 60px); /* Adjusted height */
                max-width: 1800px; /* Optional max width */
                max-height: 950px; /* Optional max height */
                margin: 10px;
            }
             .popup h2, .welcome-popup h2 { font-size: 1.8rem; }
             .popup p, .popup li, .welcome-popup p { font-size: 1rem; }
             .tooltip { font-size: 0.9rem; }
             .progress-bar { width: 150px; height: 14px; }
        }

        /* Media Query for Mobile/Tablet */
        @media (max-width: 767px) {
            .instructions {
                display: none; /* Hide desktop instructions */
            }
            .instructions-mobile {
                display: block; /* Show mobile instructions */
            }
            .controls {
                display: flex; /* Show touch controls */
            }
            #game-container {
                 height: calc(100vh - 110px); /* Adjust height to fit controls and instructions */
                 width: 100vw; /* Full width */
                 border: none; /* Optional: remove border on mobile */
                 border-radius: 0;
            }
            /* Font size adjustments already made in base styles */
             .progress-bar { width: 100px; height: 10px; }
             .tooltip { font-size: 0.8rem; padding: 0.3rem 0.5rem; }

        }

        /* Specific tweaks for landscape mobile if needed */
        @media (max-width: 767px) and (orientation: landscape) {
             #game-container {
                 height: calc(100vh - 80px); /* Less vertical space needed for controls in landscape */
             }
             .instructions-mobile {
                 bottom: 60px; /* Adjust position */
             }
             .popup, .welcome-popup {
                 max-height: 80vh; /* Adjust max height */
             }
        }

    </style>
</head>
<body>
    <!-- Top Button Container (Timeline Link) -->
    <div class="button-container">
        <a href="timeline.html" class="timeline-link">Career Timeline</a>
    </div>

    <!-- Game Area -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <!-- Progress Bar -->
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <!-- Instructions Texts (Visibility controlled by CSS) -->
    <div class="instructions">Use Arrow Keys/WASD to move, Space to jump, Enter to interact, Esc to close popups</div>
    <div class="instructions-mobile">Use on-screen buttons to move, jump, and interact</div>

    <!-- Welcome Popup -->
    <div class="welcome-popup active" id="welcome-popup">
        <button class="close-btn" onclick="closePopup('welcome-popup')" aria-label="Close Welcome Popup">×</button>
        <h2>Welcome to My Resume City!</h2>
        <p>Passionate about data analytics and payroll efficiency. Skilled in SQL, Looker Studio, and VBA. Explore my career in this vibrant city! On desktop, use Arrow Keys or WASD to move, Space to jump, and Enter to interact. On mobile, use the on-screen buttons. The current role pulses with energy. Press the close button (×) to close popups. Follow the glowing timeline across 5-year levels (2013–2017 at the bottom, 2018–2022 in the middle, 2023–Present at the top). Below lies a bustling underground metro—observe its vibrancy! Check out my <a href="https://www.linkedin.com/in/vivek-anand-nakarmi-9b8a42a3" target="_blank" rel="noopener noreferrer">LinkedIn</a> or view the Career Timeline link!</p>
        <!-- Changed button to div for styling consistency, added ARIA role -->
        <div style="text-align: center; margin-top: 1rem;">
             <button class="timeline-link" onclick="closePopup('welcome-popup')" role="button">Start Exploring</button>
        </div>
    </div>

    <!-- Dynamic Popups Container -->
    <div id="popups-container"></div>

    <!-- On-Screen Touch Controls (Visibility controlled by CSS) -->
    <div class="controls">
        <div class="left-right">
            <button class="control-btn" id="left-btn" aria-label="Move Left">←</button>
            <button class="control-btn" id="right-btn" aria-label="Move Right">→</button>
        </div>
        <div class="actions">
            <button class="control-btn" id="jump-btn" aria-label="Jump">Jump</button>
            <button class="control-btn" id="interact-btn" aria-label="Interact">Interact</button>
        </div>
    </div>

    <!-- Tooltip Element (Positioned by JS) -->
    <div class="tooltip" id="tooltip"></div>

    <script type="text/javascript">
        // Data loading functions (potentially required by hosting platform)
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            // ... (same function as before, added console.error on catch)
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error("Error processing XLSX file:", e); // Log error
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }

        // --- Popup Management ---
        function closePopup(id) {
            const popup = document.getElementById(id);
            if (popup) {
                popup.classList.remove('active');
            }
            // Only remove blur if no *other* popups are active
            const anyPopupActive = document.querySelector('.popup.active, .welcome-popup.active');
            if (!anyPopupActive) {
                document.getElementById('game-canvas')?.classList.remove('blur');
            }
        }

        function closeAllPopups() {
            document.querySelectorAll('.popup, .welcome-popup').forEach(popup => {
                popup.classList.remove('active');
            });
            document.getElementById('game-canvas')?.classList.remove('blur');
        }

        // --- Game Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
          try { // Wrap main logic in try-catch
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');

            if (!ctx) {
                console.error('Canvas 2D context is not supported.');
                alert('Sorry, your browser does not support the required Canvas features. Please try a modern browser like Chrome or Firefox.');
                // Provide a fallback or stop execution gracefully
                document.getElementById('game-container').innerHTML = '<p style="padding: 20px; text-align: center;">Game requires a modern browser with Canvas support.</p>';
                return; // Stop script execution
            }


            const gameContainer = document.getElementById('game-container');
            const tooltipElement = document.getElementById('tooltip'); // Get tooltip element
            let dpr = window.devicePixelRatio || 1;
            let scaleX = 1, scaleY = 1;
            let currentWidth = 0, currentHeight = 0; // Store current dimensions

            // --- Canvas Resizing Function ---
            function resizeCanvas() {
                try {
                    const width = gameContainer.clientWidth;
                    const height = gameContainer.clientHeight;
                    console.log('Attempting resize - Container W:', width, 'H:', height); // Debug log

                    // Avoid unnecessary resizes or errors on zero dimensions
                    if (width <= 0 || height <= 0 || (width === currentWidth && height === currentHeight)) {
                        console.log('Resize skipped (zero or same dimensions)');
                        return false;
                    }

                    currentWidth = width;
                    currentHeight = height;
                    dpr = window.devicePixelRatio || 1; // Update DPR in case it changes (zoom)

                    console.log('Resizing canvas - W:', width, 'H:', height, 'DPR:', dpr);
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    canvas.style.width = `${width}px`;
                    canvas.style.height = `${height}px`;

                    // Reset transform and apply DPR scaling
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    // No longer need ctx.scale(dpr, dpr); setTransform does this

                    // Scaling logic based on a base resolution to maintain aspect ratio
                    const baseWidth = 1900; // Original design base width
                    const baseHeight = 1000; // Original design base height
                    let tempScaleX = width / baseWidth;
                    let tempScaleY = height / baseHeight;

                    // Use the *smaller* scale factor to fit content without stretching
                    const scaleFactor = Math.min(tempScaleX, tempScaleY);
                    scaleX = scaleFactor;
                    scaleY = scaleFactor;

                    // Apply a boost for smaller screens (mobile)
                    const isMobile = window.innerWidth <= 767;
                    if (isMobile) {
                        // Consider aspect ratio. If very wide (landscape mobile), boosting X too much might be bad.
                        // If very tall (portrait mobile), boosting Y too much might be bad.
                        // Let's boost both moderately. Test this factor.
                        scaleX *= 1.2;
                        scaleY *= 1.2;
                    }

                    console.log('Calculated Scales - scaleX:', scaleX.toFixed(3), 'scaleY:', scaleY.toFixed(3));

                    // IMPORTANT: Re-calculate positions/sizes of elements if they depend *dynamically* on scale.
                    // The current implementation calculates main object sizes once initially.
                    // If resizing causes visual issues, this is where you'd update
                    // e.g., player.width = basePlayerWidth * scaleX * (isMobile ? 1.5 : 1);
                    // For now, we rely on the initial calculation + internal scaling in draw functions.

                    return true;
                } catch (error) {
                    console.error('Error during resizeCanvas:', error);
                    return false;
                }
            }

            // Initial resize attempt
            if (!resizeCanvas()) {
                 console.warn('Initial resize failed or was skipped. Retrying after slight delay.');
                 // Fallback or retry logic if needed, e.g., setTimeout(resizeCanvas, 100);
                 // For now, we assume subsequent observer calls will fix it.
            }

            // Use ResizeObserver for efficient resize handling
            const resizeObserver = new ResizeObserver(entries => {
                // We only observe one element, so entries[0] is fine
                if (entries[0]) {
                    console.log('ResizeObserver triggered');
                    resizeCanvas();
                }
            });
            resizeObserver.observe(gameContainer); // Observe the container

            // --- Game Objects Definition ---
            // Note: Base numbers are multiplied by initial scale factors.
            // Player dimensions based on initial scale
            const isMobileInitial = window.innerWidth <= 767;
            const playerWidthBase = 32;
            const playerHeightBase = 48;
            const playerMobileScale = isMobileInitial ? 1.5 : 1;
            const playerJumpMobileScale = isMobileInitial ? 1.3 : 1;
            const playerSpeedMobileScale = isMobileInitial ? 1.2 : 1;

            const player = {
                x: 150 * scaleX, // Initial position scaled
                y: 826 * scaleY,
                width: playerWidthBase * scaleX * playerMobileScale, // Initial size scaled
                height: playerHeightBase * scaleY * playerMobileScale,
                baseWidth: playerWidthBase, // Store base for potential dynamic resize
                baseHeight: playerHeightBase,
                speed: 4 * scaleX * playerSpeedMobileScale, // Scaled speed
                vy: 0,
                jumpPower: -16 * scaleY * playerJumpMobileScale, // Scaled jump
                gravity: 0.6 * scaleY, // Scaled gravity
                grounded: true
            };

            // Platforms (scaled initially)
            const platforms = [
                 // Ground levels
                { x: 0, y: 850 * scaleY, width: 1900 * scaleX, height: 20 * scaleY, type: 'ground' }, // Main ground
                { x: 100 * scaleX, y: 550 * scaleY, width: 1200 * scaleX, height: 20 * scaleY, type: 'platform' }, // Middle platform
                { x: 0, y: 250 * scaleY, width: 1200 * scaleX, height: 20 * scaleY, type: 'platform' }, // Top platform
                // Side platforms (icon area)
                { x: 1590 * scaleX, y: 850 * scaleY, width: 200 * scaleX, height: 20 * scaleY, type: 'ground' },
                { x: 1590 * scaleX, y: 650 * scaleY, width: 200 * scaleX, height: 20 * scaleY, type: 'platform' },
                { x: 1590 * scaleX, y: 450 * scaleY, width: 200 * scaleX, height: 20 * scaleY, type: 'platform' },
                { x: 1590 * scaleX, y: 250 * scaleY, width: 200 * scaleX, height: 20 * scaleY, type: 'platform' },
                // Small floating platforms
                { x: 100 * scaleX, y: 750 * scaleY, width: 50 * scaleX, height: 10 * scaleY, type: 'small_platform' },
                { x: 900 * scaleX, y: 750 * scaleY, width: 50 * scaleX, height: 10 * scaleY, type: 'small_platform' },
                { x: 100 * scaleX, y: 450 * scaleY, width: 50 * scaleX, height: 10 * scaleY, type: 'small_platform' },
                { x: 900 * scaleX, y: 450 * scaleY, width: 50 * scaleX, height: 10 * scaleY, type: 'small_platform' }
            ];


            // Resume Locations (buildings/icons - scaled initially)
            // Added base coordinates/sizes for potential future dynamic scaling refinement
            const resumeLocations = [
                { id: 'intern-cerno', title: 'Intern at Cerno', content: '<p>Mar 2013 – Jun 2013 | St. Leonards, Sydney</p><p>Responsibilities:</p><ul><li>Compared bank statements with Navision journals.</li><li>Checked invoice status and payment details.</li><li>Assisted with financial data verification.</li><li>Supported team with administrative tasks.</li></ul>', startYear: 2013, endYear: 2013, layer: 'bottom', baseX: 200, baseY: 790, baseWidth: 72, baseHeight: 72, timelineOrder: 1 },
                { id: 'intern-accountant', title: 'Intern Assistant Accountant', content: '<p>Feb 2015 – Nov 2015 | Surry Hills, Sydney</p><p>Responsibilities:</p><ul><li>Managed accounts payable/receivable using MYOB.</li><li>Reconciled bank accounts and payroll sheets.</li><li>Prepared Business Activity Statements (BAS).</li><li>Performed cost center analysis with Excel.</li></ul>', startYear: 2015, endYear: 2015, layer: 'bottom', baseX: 663, baseY: 780, baseWidth: 84, baseHeight: 84, timelineOrder: 2 },
                { id: 'payroll-officer-rashays', title: 'Payroll Officer at RASHAYS', content: '<p>Nov 2015 – Oct 2018 | Sydney, Australia</p><p>Responsibilities:</p><ul><li>Processed payroll for restaurant staff accurately.</li><li>Maintained employee records and leave balances.</li><li>Ensured compliance with payroll regulations.</li><li>Generated reports using Excel for management.</li></ul>', startYear: 2015, endYear: 2018, layer: 'bottom', baseX: 1126, baseY: 770, baseWidth: 96, baseHeight: 96, timelineOrder: 3 },
                { id: 'payroll-officer-consortio', title: 'Payroll Officer at Consortio', content: '<p>Oct 2018 – Mar 2021 | Sydney, Australia</p><p>Responsibilities:</p><ul><li>Ensured accurate salary disbursement and compliance.</li><li>Managed overpayment recovery and leave records.</li><li>Prepared reports within regulatory timeframes.</li><li>Used Excel and payroll systems for data tasks.</li></ul>', startYear: 2018, endYear: 2021, layer: 'middle', baseX: 1126, baseY: 490, baseWidth: 72, baseHeight: 72, timelineOrder: 4 },
                { id: 'payroll-team-leader', title: 'Payroll Team Leader at Consortio', content: '<p>Mar 2021 – Nov 2021 | Australia</p><p>Responsibilities:</p><ul><li>Led payroll team to ensure timely processing.</li><li>Implemented process improvements for efficiency.</li><li>Ensured data accuracy across payroll systems.</li><li>Supported compliance with payroll regulations.</li></ul>', startYear: 2021, endYear: 2021, layer: 'middle', baseX: 663, baseY: 480, baseWidth: 84, baseHeight: 84, timelineOrder: 5 },
                { id: 'payroll-manager', title: 'Payroll Manager at Consortio', content: '<p>Nov 2021 – Jun 2023 | Sydney, NSW, Australia</p><p>Responsibilities:</p><ul><li>Oversaw payroll processing for accuracy and compliance.</li><li>Developed reports using SQL and Excel for insights.</li><li>Streamlined payroll workflows with VBA automation.</li><li>Trained team on payroll systems and data tools.</li></ul>', startYear: 2021, endYear: 2023, layer: 'middle', baseX: 200, baseY: 470, baseWidth: 96, baseHeight: 96, timelineOrder: 6 },
                { id: 'data-manager', title: 'Data Manager at Consortio', content: '<p>Jul 2023 – Present | Sydney, NSW, Australia</p><p>Responsibilities:</p><ul><li>Led data strategy and analytics initiatives.</li><li>Built and maintained dashboards using Looker Studio.</li><li>Managed large datasets with SQL and Google BigQuery.</li><li>Collaborated with teams to drive data-driven decisions.</li></ul>', startYear: 2023, endYear: 'Present', layer: 'top', baseX: 200, baseY: 130, baseWidth: 108, baseHeight: 120, timelineOrder: 7, isPresent: true },
                { id: 'hobbies', title: 'Hobbies', content: '<p>Personal Interests:</p><ul><li>Coding personal projects in Python and JavaScript.</li><li>Hiking in national parks around Sydney.</li><li>Photography, focusing on landscapes and cityscapes.</li><li>Playing strategy board games with friends.</li></ul>', startYear: null, endYear: null, layer: 'bottom', baseX: 1650, baseY: 810, baseWidth: 72, baseHeight: 72, isIcon: true },
                { id: 'education', title: 'Education', content: '<p>Academic Background:</p><ul><li>Diploma in Accounting, Sydney TAFE, 2013.</li><li>Completed courses in SQL and Data Visualization.</li><li>Certified in Advanced Excel and VBA Programming.</li><li>Studied Business Analytics short course, UNSW, 2020.</li></ul>', startYear: null, endYear: null, layer: 'middle', baseX: 1650, baseY: 610, baseWidth: 72, baseHeight: 72, isIcon: true },
                { id: 'skills', title: 'Skills', content: '<p>Core Competencies:</p><ul><li>Data Analysis & Modeling</li><li>SQL & Google BigQuery</li><li>Looker Studio & Data Visualization</li><li>Microsoft Excel & VBA</li><li>Payroll Services & Data Management</li></ul>', startYear: null, endYear: null, layer: 'top', baseX: 1650, baseY: 410, baseWidth: 72, baseHeight: 72, isIcon: true },
                { id: 'projects', title: 'Projects', content: '<p>Key Achievements in Data Analytics:</p><ul><li>Built a dashboard app for payroll insights using Looker Studio.</li><li>Automated data cleaning with VBA scripts for Consortio.</li><li>Designed SQL queries for real-time reporting at RASHAYS.</li><li>Created predictive models for workforce planning.</li></ul>', startYear: null, endYear: null, layer: 'top', baseX: 1650, baseY: 178, baseWidth: 72, baseHeight: 72, isIcon: true },
                { id: 'achievements', title: 'Achievements', content: '<p>Career Highlights:</p><ul><li>Certified Data Analyst, 2023.</li><li>Streamlined payroll systems at Consortio, saving 20% time.</li><li>Completed over 100 dashboards for business insights.</li><li>Mentored payroll team to improve accuracy.</li></ul>', startYear: null, endYear: null, layer: 'top', baseX: 890, baseY: 210, baseWidth: 50, baseHeight: 50, locked: true } // Initially locked
            ];

            // Map resumeLocations to final 'locations' array, calculating initial scaled positions/sizes
            const locations = resumeLocations.map(loc => {
                // Determine ground Y based on layer
                let groundPlatformY;
                if (loc.layer === 'bottom') groundPlatformY = 850;
                else if (loc.layer === 'middle') groundPlatformY = (loc.baseX < 1500) ? 550 : 650; // Main vs side platform
                else if (loc.layer === 'top') groundPlatformY = (loc.baseX < 1500) ? 250 : (loc.baseX < 1500 ? 250 : (loc.id === 'skills' ? 450 : 250)); // Adjust based on specific top icons
                 else groundPlatformY = 850; // Default fallback

                 // Find the specific platform Y if needed for icons on the right
                 if (loc.isIcon) {
                    if (loc.id === 'hobbies') groundPlatformY = 850;
                    else if (loc.id === 'education') groundPlatformY = 650;
                    else if (loc.id === 'skills') groundPlatformY = 450;
                    else if (loc.id === 'projects') groundPlatformY = 250;
                 }

                 const calculatedGroundY = groundPlatformY * scaleY;
                 const calculatedHeight = loc.baseHeight * scaleY;

                return {
                    ...loc,
                    x: loc.baseX * scaleX,
                    y: calculatedGroundY - calculatedHeight, // Calculate y based on ground and height
                    width: loc.baseWidth * scaleX,
                    height: calculatedHeight,
                    groundY: calculatedGroundY, // Store the calculated ground Y
                    radiating: false, // Used for effects? (Keep if needed)
                    pulseVisited: false, // Tracks visited status for glow effect
                    draw: loc.isIcon ? drawIcon : drawBuilding,
                    tooltip: loc.startYear ? `${loc.startYear}${loc.endYear === 'Present' ? '–Present' : loc.endYear ? '–' + loc.endYear : ''}: ${loc.title}` : loc.title
                };
            });


            // Create popups dynamically
            const popupsContainer = document.getElementById('popups-container');
            locations.forEach(loc => {
                const popup = document.createElement('div');
                popup.className = 'popup';
                popup.id = loc.id + '-popup';
                // Added ARIA attributes for accessibility
                popup.setAttribute('role', 'dialog');
                popup.setAttribute('aria-labelledby', loc.id + '-title');
                popup.setAttribute('aria-modal', 'true');
                popup.innerHTML = `
                    <button class="close-btn" onclick="closePopup('${loc.id}-popup')" aria-label="Close ${loc.title}">×</button>
                    <h2 id="${loc.id}-title">${loc.title}</h2>
                    ${loc.content}
                `;
                popupsContainer.appendChild(popup);
            });

            // Sign definitions (scaled initially) - Placed near the buildings/icons
            const labelOffsetBase = 20; // Base offset
            const signs = locations.filter(loc => loc.title).map(loc => {
                const labelFontSize = isMobileInitial ? 10 * scaleX : 12 * scaleX; // Adjust label size dynamically?
                 return {
                    x: loc.x + loc.width / 2, // Center the sign roughly above the location
                    y: loc.y - labelOffsetBase * scaleY, // Position above the building/icon
                    label: loc.title.split(' at ')[0], // Shorten label if needed
                    baseX: loc.baseX + loc.baseWidth / 2, // Store base for potential dynamic scaling
                    baseY: loc.baseY - loc.baseHeight - labelOffsetBase
                };
            });


            // --- Traffic/Environment Definitions ---
            const lane1YBase = 990;
            const lane2YBase = 1020;
            const lane1Y = lane1YBase * scaleY;
            const lane2Y = lane2YBase * scaleY;

            const cars = [
                { type: 'sports', x: 0, y: lane1Y, width: 40 * scaleX, height: 20 * scaleY, speed: 3.5 * scaleX, color: '#FF4040', lane: 1, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: 3.5 * scaleX },
                { type: 'jeep', x: 200 * scaleX, y: lane2Y, width: 50 * scaleX, height: 30 * scaleY, speed: -2.8 * scaleX, color: '#32CD32', lane: 2, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: -2.8 * scaleX },
                { type: 'suv', x: 400 * scaleX, y: lane1Y, width: 50 * scaleX, height: 25 * scaleY, speed: 2.2 * scaleX, color: '#FF69B4', lane: 1, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: 2.2 * scaleX },
                { type: 'bus', x: 600 * scaleX, y: lane2Y, width: 70 * scaleX, height: 30 * scaleY, speed: -1.5 * scaleX, color: '#00CED1', lane: 2, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: -1.5 * scaleX },
                { type: 'sports', x: 800 * scaleX, y: lane1Y, width: 40 * scaleX, height: 20 * scaleY, speed: 3.0 * scaleX, color: '#FFD700', lane: 1, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: 3.0 * scaleX },
                { type: 'suv', x: 1000 * scaleX, y: lane2Y, width: 50 * scaleX, height: 25 * scaleY, speed: -2.0 * scaleX, color: '#A3BFFA', lane: 2, laneChangeTimer: Math.random() * 300 + 100, baseSpeed: -2.0 * scaleX }
            ];


            const trafficLights = [
                { x: 400 * scaleX, y: 970 * scaleY, state: 'green', timer: Math.random() * 300, width: 30 * scaleX, height: 10 * scaleY },
                { x: 800 * scaleX, y: 970 * scaleY, state: 'red', timer: Math.random() * 300, width: 30 * scaleX, height: 10 * scaleY },
                { x: 1200 * scaleX, y: 970 * scaleY, state: 'yellow', timer: Math.random() * 300, width: 30 * scaleX, height: 10 * scaleY }
            ];

            // Train above middle platform
            const train = { x: 0, y: 300 * scaleY, width: 120 * scaleX, height: 25 * scaleY, speed: 2 * scaleX, color: '#A3BFFA' };

            // Background Stars (regenerate positions on resize if needed, or use static large area)
             let stars = [];
             function generateStars(count) {
                stars = Array.from({ length: count }, () => ({
                    x: Math.random() * currentWidth, // Use current canvas width
                    y: Math.random() * currentHeight * 0.3, // Only in top 30%
                    radius: Math.random() * 1.5 * Math.min(scaleX, scaleY), // Scale radius slightly
                    opacity: Math.random() * 0.5 + 0.3 // Random opacity
                }));
             }
             generateStars(100); // Initial generation


            // Distant background buildings (simple shapes)
            const distantBuildings = [
                { x: 50 * scaleX, y: 800 * scaleY, width: 50 * scaleX, height: 100 * scaleY },
                { x: 120 * scaleX, y: 800 * scaleY, width: 40 * scaleX, height: 150 * scaleY },
                { x: 180 * scaleX, y: 800 * scaleY, width: 60 * scaleX, height: 80 * scaleY },
                { x: 900 * scaleX, y: 800 * scaleY, width: 50 * scaleX, height: 120 * scaleY },
                { x: 970 * scaleX, y: 800 * scaleY, width: 30 * scaleX, height: 180 * scaleY },
                { x: 1020 * scaleX, y: 800 * scaleY, width: 40 * scaleX, height: 90 * scaleY }
            ];

             // Underground Metro Area
            const undergroundBaseY = 920 * scaleY;
            const metroTrackSpacing = 30 * scaleY;
            const undergroundTrains = [
                { x: 0, y: undergroundBaseY, width: 100 * scaleX, height: 25 * scaleY, speed: 1.2 * scaleX, color: '#FF8C00' },
                { x: 400 * scaleX, y: undergroundBaseY + metroTrackSpacing, width: 100 * scaleX, height: 25 * scaleY, speed: -1.0 * scaleX, color: '#FF4040' },
                { x: 800 * scaleX, y: undergroundBaseY + metroTrackSpacing * 2, width: 100 * scaleX, height: 25 * scaleY, speed: 0.8 * scaleX, color: '#32CD32' }
            ];
            const undergroundSigns = [
                { x: 150 * scaleX, y: undergroundBaseY - 10 * scaleY, label: 'Metro L1' },
                { x: 400 * scaleX, y: undergroundBaseY - 10 * scaleY, label: 'Central Station' },
                { x: 650 * scaleX, y: undergroundBaseY - 10 * scaleY, label: 'Track 3 ->' }
            ];

            // --- Drawing Functions ---
            // (drawBuilding, drawIcon, drawCar, etc. - kept mostly the same, ensure they use passed-in scaled values correctly)
            // Added try-catch wrappers and minor logging for debugging drawing issues.

            function drawBuilding(x, y, width, height, tooltip, groundY, isPresent, loc) {
                try {
                    const baseY = groundY - height; // Use calculated groundY
                    ctx.save();
                    const gradient = ctx.createLinearGradient(x, baseY, x, baseY + height);
                    gradient.addColorStop(0, '#2A2A3A');
                    gradient.addColorStop(1, '#3A3A4A');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#00DDEB';
                    ctx.lineWidth = Math.max(1, 1.5 * scaleX); // Ensure minimum line width

                    // --- Unique Building Shapes ---
                    ctx.beginPath();
                    // (Specific building shape logic remains the same)
                    if (loc.id === 'intern-cerno') { // Simple block with antenna
                        ctx.rect(x, baseY, width, height);
                        ctx.fillStyle = '#00DDEB'; // Antenna color
                        ctx.fillRect(x + width / 2 - 2 * scaleX, baseY - 10 * scaleY, 4 * scaleX, 10 * scaleY); // Antenna
                        ctx.fillStyle = gradient; // Reset fill style
                    } else if (loc.id === 'intern-accountant') { // Slanted roof
                         ctx.moveTo(x, baseY + height); // Bottom left
                         ctx.lineTo(x, baseY + 10 * scaleY); // Top left (lower)
                         ctx.lineTo(x + width, baseY); // Top right (higher)
                         ctx.lineTo(x + width, baseY + height); // Bottom right
                         ctx.closePath();
                    } else if (loc.id === 'payroll-officer-rashays') { // Dome roof
                        ctx.moveTo(x, baseY + height); // Bottom left
                        ctx.lineTo(x, baseY + 20 * scaleY); // Start curve
                        ctx.quadraticCurveTo(x + width / 2, baseY, x + width, baseY + 20 * scaleY); // Curve top
                        ctx.lineTo(x + width, baseY + height); // Bottom right
                        ctx.closePath();
                    } else if (loc.id === 'payroll-officer-consortio') { // Simple with random light
                         ctx.rect(x, baseY, width, height);
                         ctx.fillStyle = '#00DDEB'; // Light color
                         ctx.fillRect(x + width / 2 - 5 * scaleX, baseY - 5 * scaleY, 10 * scaleX, (Math.random() * 5 + 5) * scaleY); // Random height light
                         ctx.fillStyle = gradient;
                    } else if (loc.id === 'payroll-team-leader') { // Peaked roof
                         ctx.moveTo(x, baseY + height); // Bottom left
                         ctx.lineTo(x, baseY + 5 * scaleY); // Start peak left
                         ctx.lineTo(x + width / 2, baseY); // Peak center
                         ctx.lineTo(x + width, baseY + 5 * scaleY); // Start peak right
                         ctx.lineTo(x + width, baseY + height); // Bottom right
                         ctx.closePath();
                    } else if (loc.id === 'payroll-manager') { // Tapered top
                         ctx.moveTo(x, baseY + height); // Bottom left
                         ctx.lineTo(x + 5 * scaleX, baseY); // Top left (inset)
                         ctx.lineTo(x + width - 5 * scaleX, baseY); // Top right (inset)
                         ctx.lineTo(x + width, baseY + height); // Bottom right
                         ctx.closePath();
                    } else if (loc.id === 'data-manager') { // Curved top building (like Rashays but maybe different curve)
                        ctx.moveTo(x, baseY + height);
                        ctx.lineTo(x, baseY + 20 * scaleY);
                        ctx.quadraticCurveTo(x + width / 2, baseY - 10 * scaleY, x + width, baseY + 20 * scaleY); // Higher curve
                        ctx.lineTo(x + width, baseY + height);
                        ctx.closePath();
                    } else { // Default rectangular building
                        ctx.rect(x, baseY, width, height);
                    }
                    ctx.fill();
                    ctx.stroke();


                    // --- Windows ---
                    // Dynamic calculation based on current scale, ensuring minimum size
                    const minWindowSize = 4;
                    const windowWidth = Math.max(minWindowSize, 8 * scaleX * (isMobileInitial ? 1.1 : 1));
                    const windowHeight = Math.max(minWindowSize, 6 * scaleY * (isMobileInitial ? 1.1 : 1));
                    const windowGap = Math.max(1, 2 * Math.min(scaleX, scaleY)); // Scaled gap

                    const cols = Math.max(1, Math.floor(width / (windowWidth + windowGap))); // Calculate columns based on available width
                    const rows = Math.max(1, Math.floor((height * 0.8) / (windowHeight + windowGap))); // Calculate rows based on available height (leave some margin)

                    const totalWindowWidth = cols * windowWidth + (cols - 1) * windowGap;
                    const totalWindowHeight = rows * windowHeight + (rows - 1) * windowGap;
                    const offsetX = (width - totalWindowWidth) / 2; // Center windows horizontally
                    const offsetY = (height - totalWindowHeight) * 0.3; // Position windows vertically (closer to top)

                    ctx.fillStyle = '#00DDEB'; // Window color
                    ctx.strokeStyle = '#FFFFFF'; // Window frame color
                    ctx.lineWidth = Math.max(0.5, 0.5 * scaleX); // Thin window frames

                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            let winX = x + offsetX + j * (windowWidth + windowGap);
                            let winY = baseY + offsetY + i * (windowHeight + windowGap);

                             // Add slight variation for specific buildings if needed (original logic kept)
                             if (loc.id === 'intern-accountant') {
                                winY += ((cols - 1 - j) / Math.max(1, cols - 1)) * 10 * scaleY * 0.5; // Subtle slant effect
                            } else if (loc.id === 'payroll-officer-rashays' && i === 0) {
                                winY += Math.abs(j - (cols-1)/2) * 4 * scaleY * 0.5; // Curve effect for top row
                            } else if (loc.id === 'payroll-manager') {
                                const taperOffset = Math.min(j, cols - 1 - j);
                                winY += (taperOffset * 2 * scaleY * 0.5); // Taper effect
                            }


                            // Only draw if within building bounds (simple check)
                            if (winY + windowHeight < groundY - 5 * scaleY) { // Leave small margin at bottom
                                ctx.fillRect(winX, winY, windowWidth, windowHeight);
                                ctx.strokeRect(winX, winY, windowWidth, windowHeight);
                            }
                        }
                    }

                    // --- Ground Shadow ---
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Subtle shadow
                    ctx.fillRect(x, groundY, width, 5 * scaleY); // Thin shadow below building

                    // --- Pulse Effect (Present/Visited) ---
                    if (isPresent || loc.pulseVisited) {
                        ctx.globalAlpha = pulseOpacity; // Use pulsing opacity
                        ctx.strokeStyle = '#00DDEB';
                        ctx.lineWidth = (isPresent ? 3 : 2) * Math.max(1, scaleX); // Thicker pulse for present role
                        const pulseOffset = (isPresent ? 2 : 1) * Math.max(1, scaleX);
                        ctx.strokeRect(x - pulseOffset, baseY - pulseOffset, width + 2 * pulseOffset, height + 2 * pulseOffset);
                        ctx.globalAlpha = 1; // Reset alpha
                    }

                    ctx.restore();
                } catch (error) {
                    console.error(`Error drawing building ${loc?.id || 'unknown'}:`, error);
                }
            }

            function drawIcon(x, y, width, height, tooltip, groundY, isPresent, loc) {
                 try {
                    const baseY = groundY - height;
                    ctx.save();
                    const gradient = ctx.createLinearGradient(x, baseY, x, baseY + height);
                    gradient.addColorStop(0, '#00DDEB');
                    gradient.addColorStop(1, '#00A3B0');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = Math.max(1, 2 * scaleX);

                    ctx.beginPath();
                    // --- Unique Icon Shapes --- (Simplified slightly for clarity)
                    const cx = x + width / 2;
                    const cy = baseY + height / 2;
                    const r = Math.min(width, height) * 0.4; // Base radius on smaller dimension

                    if (loc.id === 'hobbies') { // Heart shape
                        const heartSize = r * 1.8;
                         ctx.moveTo(cx, cy - heartSize * 0.25);
                        ctx.bezierCurveTo(cx + heartSize * 0.5, cy - heartSize * 0.5, cx + heartSize * 0.5, cy + heartSize * 0.25, cx, cy + heartSize * 0.5);
                        ctx.bezierCurveTo(cx - heartSize * 0.5, cy + heartSize * 0.25, cx - heartSize * 0.5, cy - heartSize * 0.5, cx, cy - heartSize * 0.25);
                    } else if (loc.id === 'education') { // Mortarboard/Cap shape
                        const capWidth = width * 0.8;
                        const capHeight = height * 0.4;
                        ctx.rect(x + (width - capWidth) / 2, baseY + height * 0.1, capWidth, capHeight); // Main square top
                        // Base part
                        ctx.moveTo(cx - capWidth * 0.3, baseY + height * 0.5);
                        ctx.lineTo(cx + capWidth * 0.3, baseY + height * 0.5);
                        ctx.lineTo(cx + capWidth * 0.2, baseY + height * 0.9);
                        ctx.lineTo(cx - capWidth * 0.2, baseY + height * 0.9);
                        ctx.closePath();
                        // Tassel (simple line)
                         ctx.moveTo(cx, baseY + height * 0.3);
                         ctx.lineTo(cx + width * 0.3, baseY + height * 0.6);

                    } else if (loc.id === 'skills') { // Gear shape
                        const numTeeth = 8;
                         for (let i = 0; i < numTeeth; i++) {
                            const angle = (i * 2 * Math.PI) / numTeeth;
                            const angleNext = ((i + 0.5) * 2 * Math.PI) / numTeeth;
                            ctx.lineTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r); // Inner point
                            ctx.lineTo(cx + Math.cos(angleNext) * r * 1.2, cy + Math.sin(angleNext) * r * 1.2); // Outer point
                        }
                         ctx.closePath();
                         // Inner circle
                         ctx.moveTo(cx + r * 0.5, cy); // Move to start point for inner circle arc
                         ctx.arc(cx, cy, r * 0.5, 0, Math.PI * 2);

                    } else if (loc.id === 'projects') { // Lightbulb shape
                        const bulbRadius = r * 0.8;
                        const neckHeight = height * 0.3;
                        ctx.arc(cx, baseY + height * 0.4, bulbRadius, 0, Math.PI * 2); // Bulb circle
                        // Base/Neck
                        ctx.rect(cx - bulbRadius * 0.3, baseY + height * 0.4 + bulbRadius * 0.8, bulbRadius * 0.6, neckHeight);
                        // Simple lines inside bulb
                         ctx.moveTo(cx - bulbRadius*0.4, baseY + height * 0.4);
                         ctx.lineTo(cx + bulbRadius*0.4, baseY + height * 0.4);

                    } else { // Default fallback: simple circle or square
                         ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    }

                    ctx.fill(); // Fill the main shape
                     if (loc.id !== 'skills') ctx.stroke(); // Stroke outline (gear doesn't need separate stroke)


                     // Add details or highlights if needed (e.g., gear center)
                     if (loc.id === 'skills') {
                         // Fill the inner circle with a different color/alpha?
                         // ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                         // ctx.fill(); // Fill the inner circle path created earlier
                         ctx.stroke(); // Stroke the whole gear shape now
                     }
                     if (loc.id === 'hobbies') {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Highlight on heart
                        ctx.globalAlpha = pulseOpacity * 0.5 + 0.5;
                        ctx.beginPath();
                        ctx.arc(cx + r * 0.3, cy - r*0.3, 3 * scaleX, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                     }


                    // --- Ground Shadow ---
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(x, groundY, width, 5 * scaleY);

                    // --- Pulse / Glow Effect ---
                    // Apply a general glow using shadow for icons
                    ctx.shadowColor = '#00DDEB';
                    ctx.shadowBlur = 15 * Math.max(1, scaleX);
                    // Redraw slightly larger for glow effect base
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = 1; // Thin line for glow redraw
                    ctx.stroke(); // Stroke the shape again to apply shadow
                    ctx.shadowBlur = 0; // Reset shadow
                    ctx.globalAlpha = 1; // Reset alpha


                    // --- Pulse Effect (Present/Visited) --- (similar to building)
                    if (isPresent || loc.pulseVisited) {
                        ctx.globalAlpha = pulseOpacity;
                        ctx.strokeStyle = '#00DDEB';
                        ctx.lineWidth = (isPresent ? 3 : 2) * Math.max(1, scaleX);
                        const pulseOffset = (isPresent ? 2 : 1) * Math.max(1, scaleX);
                        // Draw a bounding box for pulse on icons for simplicity
                        ctx.strokeRect(x - pulseOffset, baseY - pulseOffset, width + 2 * pulseOffset, height + 2 * pulseOffset);
                        ctx.globalAlpha = 1;
                    }

                    ctx.restore();
                } catch (error) {
                     console.error(`Error drawing icon ${loc?.id || 'unknown'}:`, error);
                }
            }

            // Other draw functions (Car, Train, TrafficLight, Sign, etc.) remain largely the same
            // Ensure they use current scale factors for details if needed. Added try-catch.
            function drawCar(car) { /* ... (add try-catch) ... */ }
            function drawTrafficLight(light) { /* ... (add try-catch) ... */ }
            function drawTrain(train) { /* ... (add try-catch) ... */ }
            function drawUndergroundTrain(train) { /* ... (add try-catch) ... */ }
            function drawSign(sign) {
                 try {
                    ctx.save();
                    const fontSize = Math.max(10, 12 * Math.min(scaleX, scaleY)); // Scale font size, min 10px
                    ctx.font = `bold ${fontSize}px 'Inter', sans-serif`;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.textAlign = 'center'; // Center text horizontally
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 600) * 0.3; // Subtle pulse
                    ctx.fillText(sign.label, sign.x, sign.y); // Use sign's scaled x, y
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } catch (error) {
                    console.error('Error drawing sign:', error);
                }
            }
            function drawDistantBuilding(building) { /* ... (add try-catch) ... */ }

            // --- Game State Variables ---
            let xp = 0;
            const visited = new Set();
            let achievementsUnlocked = false; // Track if achievement location is unlocked
            let pulseOpacity = 0.4; // For flashing effect
            let pulseDirection = 1;
            let nearestLoc = null; // Track nearest interactive location
            let minDistance = Infinity;
            let lastTimestamp = 0; // For delta time calculation


            // --- Input Handling Setup ---
            const keys = {}; // Stores the state of currently pressed keys/buttons

            // Keyboard Listeners
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                // Remap arrow keys to wasd for simplicity in checks
                if (key === 'arrowleft') keys['a'] = true;
                if (key === 'arrowright') keys['d'] = true;
                if (key === 'arrowup' || key === ' ') keys[' '] = true; // Map ArrowUp to space for jump
                if (key === 'enter') keys['enter'] = true; // Keep enter separate

                // Handle jump (only on initial press and if grounded)
                if (keys[' '] && player.grounded) {
                    player.vy = player.jumpPower;
                    player.grounded = false;
                    // Optional: consume the space key state immediately after jump to prevent holding jump
                    // keys[' '] = false;
                }

                // Handle interaction
                if (keys['enter']) {
                    checkInteraction();
                    keys['enter'] = false; // Consume enter press immediately
                }

                // Handle popup closing
                if (key === 'escape') {
                    closeAllPopups();
                }
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                // Remap arrow keys on keyup too
                if (key === 'arrowleft') keys['a'] = false;
                if (key === 'arrowright') keys['d'] = false;
                if (key === 'arrowup' || key === ' ') keys[' '] = false;
            });

            // Touch Control Listeners
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');
            const jumpBtn = document.getElementById('jump-btn');
            const interactBtn = document.getElementById('interact-btn');

            // Helper function for touch events
            function handleTouch(buttonId, keyToSimulate, isStart) {
                const btn = document.getElementById(buttonId);
                if (!btn) return;
                const eventType = isStart ? 'touchstart' : 'touchend';
                const counterEventType = isStart ? 'touchend' : 'touchstart'; // To clear if touch leaves button

                 btn.addEventListener(eventType, (e) => {
                    e.preventDefault(); // Prevent default actions like scroll/zoom
                    keys[keyToSimulate] = isStart;
                     // Special handling for jump on touchstart
                     if (keyToSimulate === ' ' && isStart && player.grounded) {
                         player.vy = player.jumpPower;
                         player.grounded = false;
                         // keys[keyToSimulate] = false; // Consume immediately? Optional.
                     }
                     // Special handling for interaction on touchstart
                     if (keyToSimulate === 'enter' && isStart) {
                         checkInteraction();
                         keys[keyToSimulate] = false; // Consume immediately
                     }
                });

                 // Add touchend/touchleave/touchcancel to ensure key state is reset if finger slides off
                 ['touchend', 'touchleave', 'touchcancel'].forEach(endEvent => {
                    btn.addEventListener(endEvent, (e) => {
                         // Only set to false if the event type matches the expectation (touchend for start, etc.)
                         // This check might be overly complex, simply setting to false on any end event is usually fine.
                        if (isStart && eventType === 'touchstart') {
                             keys[keyToSimulate] = false;
                        } else if (!isStart && eventType === 'touchend') {
                             // No action needed usually for touchend mapping?
                        }
                         // Simpler: always set to false on end/leave/cancel
                        keys[keyToSimulate] = false;
                    });
                 });
            }


            handleTouch('left-btn', 'a', true); // Touchstart sets 'a' to true
            handleTouch('left-btn', 'a', false); // Touchend sets 'a' to false

            handleTouch('right-btn', 'd', true);
            handleTouch('right-btn', 'd', false);

            handleTouch('jump-btn', ' ', true); // Jump triggers on touchstart
            // No touchend needed for jump as it's instant

            handleTouch('interact-btn', 'enter', true); // Interact triggers on touchstart
            // No touchend needed for interact as it's instant


            // --- Interaction Logic ---
            function checkInteraction() {
                if (nearestLoc && minDistance < 70 * Math.min(scaleX, scaleY)) { // Slightly larger interaction radius
                    // Check if the location is the locked achievement location
                    if (nearestLoc.locked) {
                        // Optionally show a message like "You need to explore more first!"
                         showTemporaryMessage("Explore more locations to unlock this!");
                        console.log("Attempted to interact with locked location:", nearestLoc.id);
                        return;
                    }

                    console.log("Interacting with:", nearestLoc.id);
                    closeAllPopups(); // Close any existing popups first
                    const popup = document.getElementById(nearestLoc.id + '-popup');
                    if (popup) {
                        popup.classList.add('active');
                        document.getElementById('game-canvas')?.classList.add('blur');
                    } else {
                        console.error("Popup not found for ID:", nearestLoc.id + '-popup');
                    }
                } else {
                    console.log("No location near enough to interact.");
                }
            }

             // Helper for temporary messages (e.g., for locked interactions)
            function showTemporaryMessage(message) {
                 // Could implement this by briefly showing text on the canvas or a simple temporary HTML element
                 console.log("TEMP MESSAGE:", message); // Simple console log for now
                 // Example using tooltip element temporarily:
                 tooltipElement.textContent = message;
                 tooltipElement.style.display = 'block';
                 tooltipElement.style.left = `${player.x + player.width / 2}px`; // Position near player
                 tooltipElement.style.top = `${player.y - 30}px`;
                 tooltipElement.style.background = 'rgba(255, 64, 64, 0.9)'; // Reddish background for notice
                 tooltipElement.style.color = '#FFFFFF';
                 setTimeout(() => {
                     if (tooltipElement.textContent === message) { // Hide only if message hasn't changed
                         tooltipElement.style.display = 'none';
                         tooltipElement.style.background = 'rgba(0, 221, 235, 0.95)'; // Reset style
                         tooltipElement.style.color = '#14141E';
                     }
                 }, 2000); // Show for 2 seconds
             }


            // --- Game Loop ---
            function update(timestamp) {
                try { // Wrap update logic in try-catch
                    const deltaTime = (timestamp - lastTimestamp) / 1000; // Time since last frame in seconds
                    lastTimestamp = timestamp;
                    const effectiveDeltaTime = Math.min(deltaTime, 0.032); // Clamp delta time to avoid large jumps (max ~30fps physics)

                    // --- Player Movement ---
                    let targetSpeed = 0;
                    if (keys['a']) targetSpeed -= player.speed;
                    if (keys['d']) targetSpeed += player.speed;

                    // Apply movement based on delta time for frame rate independence
                    player.x += targetSpeed * effectiveDeltaTime * 60; // Multiply by 60 to compensate for dividing speed/gravity by 60 earlier? No, speed is pixels per frame in original code. Let's adjust:
                    // Speed should be pixels per second. Adjust player.speed definition.
                    // OR keep speed as pixels per frame and DON'T use deltaTime for movement.
                    // Let's stick to original frame-based movement for simplicity here.
                    player.x += targetSpeed;


                    // --- Player Physics ---
                    player.vy += player.gravity; // Apply gravity (frame-based)
                    player.y += player.vy; // Apply vertical velocity

                    // --- Collision Detection ---
                    player.grounded = false;
                    let groundY = currentHeight; // Fall to bottom of canvas if no platform hit

                     // Combine platforms and interactive locations for collision checks
                    // Filter out non-collidable elements if needed
                    const collidablePlatforms = [
                        ...platforms,
                        // Treat buildings/icons as platforms too
                        ...locations.map(loc => ({
                            x: loc.x,
                            y: loc.groundY - 2, // Small buffer on top of buildings
                            width: loc.width,
                            height: 20 * scaleY, // Treat only the top surface as collidable platform
                            type: 'location_top'
                         }))
                    ];

                    collidablePlatforms.forEach(platform => {
                        // Basic Axis-Aligned Bounding Box (AABB) collision check
                        const playerBottom = player.y + player.height;
                        const playerPreviousBottom = playerBottom - player.vy; // Position in previous frame
                        const platformTop = platform.y;
                        const playerRight = player.x + player.width;
                        const platformRight = platform.x + platform.width;

                        // Check horizontal overlap
                        if (playerRight > platform.x && player.x < platformRight) {
                             // Check vertical collision: Was player above platform last frame, and is now intersecting or below?
                             // And is player moving downwards (vy > 0)?
                            if (player.vy >= 0 && playerPreviousBottom <= platformTop && playerBottom >= platformTop) {
                                player.y = platformTop - player.height; // Correct position
                                player.vy = 0; // Stop vertical movement
                                player.grounded = true;
                            }
                            // Simple side collision ( rudimentary - can cause sticking)
                             /* else if (playerBottom > platformTop && player.y < platform.y + platform.height) {
                                // Check which side collision occurred from
                                if (targetSpeed > 0 && player.x + player.width - targetSpeed <= platform.x) { // Hit left side
                                    player.x = platform.x - player.width;
                                } else if (targetSpeed < 0 && player.x - targetSpeed >= platformRight) { // Hit right side
                                     player.x = platformRight;
                                }
                             } */
                        }
                    });


                    // Prevent falling through the absolute bottom ground (canvas height - small buffer)
                    const absoluteGroundY = currentHeight - 10 * scaleY;
                    if (player.y + player.height > absoluteGroundY) {
                         player.y = absoluteGroundY - player.height;
                         player.vy = 0;
                         player.grounded = true;
                    }

                    // --- Keep Player within Bounds ---
                    player.x = Math.max(0, Math.min(currentWidth - player.width, player.x));
                    // player.y = Math.max(0, player.y); // Prevent going above screen? Optional.


                    // --- Update Environment ---
                    pulseOpacity += pulseDirection * 0.02; // Update pulse effect
                    if (pulseOpacity >= 0.8 || pulseOpacity <= 0.4) pulseDirection *= -1;

                    // Update traffic lights, cars, trains (frame-based updates)
                     trafficLights.forEach(light => { /* ... (logic unchanged) ... */ });
                     cars.forEach(car => { /* ... (logic unchanged) ... */ });
                     train.x += train.speed;
                     if (train.x > currentWidth) train.x = -train.width;
                     if (train.x + train.width < 0) train.x = currentWidth;
                     undergroundTrains.forEach(ut => { ut.x += ut.speed; /* wrap around logic */ });
                     stars.forEach(star => { star.opacity += 0.01; if (star.opacity > 1) star.opacity -= 1; }); // Simple twinkle


                    // --- Find Nearest Location & Handle Interaction State ---
                    nearestLoc = null;
                    minDistance = Infinity;
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;

                    locations.forEach(loc => {
                         // Calculate distance from player center to location center/interaction point
                         const locCenterX = loc.x + loc.width / 2;
                         const locCenterY = loc.y + loc.height / 2; // Center of the visual element
                         const dx = playerCenterX - locCenterX;
                         const dy = playerCenterY - locCenterY;
                         const distance = Math.sqrt(dx * dx + dy * dy);

                         if (distance < minDistance) {
                             minDistance = distance;
                             nearestLoc = loc;
                         }

                         // Check for unlocking achievements / gaining XP
                         const interactionRadius = 70 * Math.min(scaleX, scaleY); // Use the same radius as interaction check
                         if (distance < interactionRadius && !visited.has(loc.id) && !loc.locked) {
                            xp += 10;
                            visited.add(loc.id);
                            loc.pulseVisited = true; // Mark as visited for visual feedback
                            console.log(`Visited ${loc.id}, XP: ${xp}`);

                             // Check if achievements should be unlocked
                            const requiredXP = 70; // Example: Unlock after visiting 7 locations
                            if (!achievementsUnlocked && xp >= requiredXP) {
                                const achievementLoc = locations.find(l => l.id === 'achievements');
                                if (achievementLoc) {
                                    achievementsUnlocked = true;
                                    achievementLoc.locked = false; // Unlock the location
                                    console.log("Achievements location unlocked!");
                                     // Optionally trigger the achievement popup immediately
                                     // closeAllPopups();
                                     // document.getElementById('achievements-popup')?.classList.add('active');
                                     // document.getElementById('game-canvas')?.classList.add('blur');
                                     showTemporaryMessage("Achievement Zone Unlocked!"); // Notify player
                                }
                            }
                        }
                    });

                    // Update Progress Bar
                    const progressFill = document.getElementById('progress-fill');
                    const maxXP = 100; // Or adjust based on number of locations
                    const progressPercent = Math.min((xp / maxXP) * 100, 100);
                    if (progressFill) progressFill.style.width = `${progressPercent}%`;

                    // --- Tooltip Update ---
                    const interactionRadius = 70 * Math.min(scaleX, scaleY);
                     if (nearestLoc && minDistance < interactionRadius) {
                         tooltipElement.style.display = 'block';
                         tooltipElement.textContent = nearestLoc.locked ? `${nearestLoc.title} (Locked)` : `[Enter] ${nearestLoc.tooltip}`;

                         // Position tooltip above the location, adjusting for screen edges
                         let tooltipX = nearestLoc.x + nearestLoc.width / 2 - tooltipElement.offsetWidth / 2;
                         let tooltipY = nearestLoc.y - tooltipElement.offsetHeight - 10; // 10px margin above

                         // Prevent going off-screen left/right
                         tooltipX = Math.max(5, Math.min(tooltipX, currentWidth - tooltipElement.offsetWidth - 5));
                         // Prevent going off-screen top (less likely)
                         tooltipY = Math.max(5, tooltipY);

                         tooltipElement.style.left = `${tooltipX}px`;
                         tooltipElement.style.top = `${tooltipY}px`;
                     } else {
                         tooltipElement.style.display = 'none';
                     }


                    // --- Drawing ---
                    // Clear canvas
                    ctx.clearRect(0, 0, currentWidth, currentHeight); // Use canvas logical width/height

                    // Draw Background Gradient
                    const gradient = ctx.createLinearGradient(0, 0, 0, currentHeight);
                    gradient.addColorStop(0, '#14141E');
                    gradient.addColorStop(0.8, '#1E3A5F');
                    gradient.addColorStop(1, '#3A3A4A'); // Darker bottom for underground feel
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, currentWidth, currentHeight);

                    // Draw Stars
                    stars.forEach(star => {
                        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity * 0.8})`; // Dimmer stars
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw Distant Buildings
                    distantBuildings.forEach(drawDistantBuilding);

                    // Draw Train Track Area
                    ctx.fillStyle = '#3A3A4A'; // Track bed color
                    ctx.fillRect(0, 280 * scaleY, currentWidth, 12 * scaleY);
                    ctx.fillStyle = '#00DDEB'; // Glowing rail color
                    ctx.fillRect(0, 286 * scaleY, currentWidth, 3 * scaleY); // Top rail
                     ctx.fillRect(0, 290 * scaleY, currentWidth, 3 * scaleY); // Bottom rail

                    // Draw Train
                    drawTrain(train);

                    // Draw Platforms
                    ctx.fillStyle = '#3A3A4A'; // Platform color
                     ctx.strokeStyle = '#00DDEB'; // Platform edge highlight
                     ctx.lineWidth = Math.max(1, 2 * scaleX);
                     platforms.forEach(platform => {
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                        // Add a subtle top edge highlight
                         ctx.beginPath();
                         ctx.moveTo(platform.x, platform.y);
                         ctx.lineTo(platform.x + platform.width, platform.y);
                         ctx.stroke();
                    });


                    // Draw Underground Area
                    const undergroundHeight = currentHeight - undergroundBaseY + 20 * scaleY; // Extend slightly below canvas edge
                    ctx.fillStyle = '#2A2A3A'; // Darker background for underground
                    ctx.fillRect(0, undergroundBaseY, currentWidth, undergroundHeight);
                    // Draw Metro Tracks
                    ctx.fillStyle = '#1E1E2A'; // Even darker track bed
                    ctx.strokeStyle = '#FFC107'; // Yellow safety line / rail highlight
                    ctx.lineWidth = Math.max(1, 2 * scaleY);
                     for (let i=0; i<3; i++) {
                         const trackY = undergroundBaseY + i * metroTrackSpacing;
                         ctx.fillRect(0, trackY - 2*scaleY, currentWidth, 25*scaleY + 4*scaleY); // Track bed area
                         // Draw rails
                         ctx.beginPath();
                         ctx.moveTo(0, trackY + 5*scaleY);
                         ctx.lineTo(currentWidth, trackY + 5*scaleY);
                         ctx.moveTo(0, trackY + 20*scaleY);
                         ctx.lineTo(currentWidth, trackY + 20*scaleY);
                         ctx.stroke();
                     }
                     // Draw underground elements
                    undergroundTrains.forEach(drawUndergroundTrain);
                    undergroundSigns.forEach(drawSign); // Draw signs within the area
                     // Draw tunnel lights
                     ctx.fillStyle = '#FFFFE0';
                     for (let x = 60 * scaleX; x < currentWidth; x += 120 * scaleX) {
                         ctx.beginPath();
                         ctx.arc(x, undergroundBaseY - 15 * scaleY, 6 * scaleX, 0, Math.PI * 2);
                         ctx.fill();
                     }

                    // Draw Road Area (Below main ground)
                     const roadY = 870 * scaleY; // Position road slightly below main ground
                     const roadHeight = currentHeight - roadY;
                     ctx.fillStyle = '#555555'; // Road color
                     ctx.fillRect(0, roadY, currentWidth, roadHeight);
                     // Road Lines
                     ctx.strokeStyle = '#FFFFFF';
                     ctx.lineWidth = Math.max(1, 2 * scaleX);
                     ctx.setLineDash([15 * scaleX, 10 * scaleX]); // Dashed line style
                     ctx.beginPath();
                     ctx.moveTo(0, roadY + roadHeight / 2); // Center line
                     ctx.lineTo(currentWidth, roadY + roadHeight / 2);
                     ctx.stroke();
                     ctx.setLineDash([]); // Reset line dash


                    // Draw Traffic Elements
                    trafficLights.forEach(drawTrafficLight);
                    cars.forEach(drawCar);

                    // Draw Interactive Locations (Buildings/Icons)
                    locations.forEach(loc => {
                         loc.draw(loc.x, loc.y + loc.height, loc.width, loc.height, loc.tooltip, loc.groundY, loc.isPresent || loc.id === 'achievements' && !loc.locked, loc);
                     });

                    // Draw Signs above locations
                    signs.forEach(drawSign);

                    // Draw Player
                    ctx.fillStyle = '#FF4040'; // Player color
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    // Optional: Add simple player details (eyes?)
                     ctx.fillStyle = '#FFFFFF';
                     ctx.fillRect(player.x + player.width * 0.3, player.y + player.height * 0.2, 4*scaleX, 4*scaleY);
                     ctx.fillRect(player.x + player.width * 0.6, player.y + player.height * 0.2, 4*scaleX, 4*scaleY);


                    // --- Request Next Frame ---
                    requestAnimationFrame(update);

                } catch (error) {
                    console.error("Error in game loop (update function):", error);
                    // Optionally stop the loop or display an error message
                    // alert("An error occurred in the game loop. Please check the console.");
                     // No 'return' here, try to continue if possible, or add a flag to stop loop
                }
            }

            // Start the game loop
             console.log("Starting game loop...");
            requestAnimationFrame(update);

         } catch (globalError) {
             console.error("A critical error occurred during initialization:", globalError);
             alert("Failed to initialize the interactive resume. Please check the console for details.");
              // Display fallback content
             document.getElementById('game-container').innerHTML = '<p style="padding: 20px; text-align: center;">An error occurred while loading the experience.</p>';
         }
        });
    </script>
</body>
</html>